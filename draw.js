/*
 * Required Notice: Copyright 2025 Gabriel Levy. All rights reserved.
 * Licensed under the Polyform Noncommercial License 1.0.0
 */

import * as THREE from "three";
import { Daydream, labels, XY } from "./driver.js";
import { Dot, angleBetween, fibSpiral, vectorPool, quaternionPool, yToPhi } from "./geometry.js";
import { quinticKernel } from "./filters.js";
import { wrap, fastAtan2 } from "./util.js";
import { TWO_PI } from "./3dmath.js";
import { StaticPool } from "./StaticPool.js";

/** @type {StaticPool} Global pool for Dot objects. */
export const dotPool = new StaticPool(Dot, 500000);

// Temps
const _tempVec = new THREE.Vector3();
const _distVec1 = new THREE.Vector3();
const _distVec2 = new THREE.Vector3();
const _distVec3 = new THREE.Vector3();
const _distVec4 = new THREE.Vector3();
const _distVec5 = new THREE.Vector3();
const _distVec6 = new THREE.Vector3();

/**
 * Represents a path composed of connected points on the sphere.
 */
export class Path {
  /**
   * @param {THREE.Vector3} initialPos - The starting position of the path.
   */
  constructor(initialPos) {
    this.points = [initialPos.clone()];
  }

  /**
   * Collapses the path to only the last point.
   */
  collapse() {
    this.points = [this.points[this.points.length - 1]];
  }

  /**
   * Gets the number of points in the path.
   * @returns {number} The length of the path.
   */
  length() {
    return this.points.length;
  }

  /**
   * Appends a line segment between two vectors to the path.
   * @param {THREE.Vector3} c1 - The start vector.
   * @param {THREE.Vector3} c2 - The end vector.
   * @param {boolean} [longWay=false] - If true, take the longer arc.
   * @param {Function} [easingFn=(t) => t] - An unused easing function (retained for signature).
   * @returns {Path} The path instance.
   */
  appendLine(c1, c2, longWay = false, easingFn = (t) => t) {
    if (this.points.length > 0) {
      this.points.pop();
    }
    this.points.push(c2.clone());
    return this;
  }

  /**
   * Appends a segment generated by a plotting function.
   * @param {Function} plotFn - Function that returns a vector based on a domain parameter t.
   * @param {number} domain - The range of the input parameter for plotFn.
   * @param {number} samples - The number of points to sample.
   * @param {Function} [easingFn=(t) => t] - The easing function to apply to the input parameter.
   * @returns {Path} The path instance.
   */
  appendSegment(plotFn, domain, samples, easingFn = (t) => t) {
    if (this.points.length > 0) {
      this.points.pop();
    }
    for (let t = 0; t <= samples; t++) {
      // Clone
      this.points.push(plotFn(easingFn(t / samples) * domain).clone());
    }
    return this;
  }

  /**
   * Gets a point on the path based on a normalized parameter t.
   * @param {number} t - Normalized position along the path [0, 1].
   * @returns {THREE.Vector3} A clone of the point at the given position.
   */
  getPoint(t) {
    const rawIndex = t * (this.points.length - 1);
    const i = Math.floor(rawIndex);
    const f = rawIndex - i;

    // Check end
    if (i >= this.points.length - 1) {
      return vectorPool.acquire().copy(this.points[this.points.length - 1]);
    }

    const p1 = this.points[i];
    const p2 = this.points[i + 1];
    return vectorPool.acquire().copy(p1).lerp(p2, f);
  }
}

/**
 * Represents a path defined by a single procedural function.
 */
export class ProceduralPath {
  /**
   * @param {Function} pathFn - Function that takes a parameter t [0, 1] and returns a THREE.Vector3.
   */
  constructor(pathFn) {
    this.f = pathFn;
  }

  /**
   * Gets a point on the path.
   * @param {number} t - Normalized position along the path [0, 1].
   * @returns {THREE.Vector3} The point on the path.
   */
  getPoint(t) {
    return this.f(t);
  }
}



/**
 * Draws a motion trail by tweening between orientations in the queue.
 * @param {Orientation} orientation - The orientation object containing the motion history.
 * @param {Function} drawFn - Function to draw a segment (takes orientation quaternion and normalized progress).
 */
export const tween = (orientation, drawFn) => {
  let s = orientation.length();
  let start = (s > 1) ? 1 : 0;
  for (let i = start; i < s; ++i) {
    drawFn(orientation.get(i), (s - 1 - i) / s);
  }
}

/**
 * Performs a deep tween on an OrientationTrail, handling interpolation between frames.
 * @param {OrientationTrail} trail - The trail of orientation histories.
 * @param {Function} drawFn - Function to draw a sample (takes quaternion and global time t).
 */
export const deepTween = (trail, drawFn) => {
  const dt = 1.0 / trail.capacity;
  tween(trail, (frame, t) => {
    tween(frame, (q, subT) => {
      const globalT = t + subT * dt;
      drawFn(q, globalT);
    });
  });
}

/**
 * Creates a basis object { u, v, w } from an orientation and normal.
 * @param {THREE.Quaternion} orientation - The orientation quaternion.
 * @param {THREE.Vector3} normal - The local normal vector.
 * @returns {{u: THREE.Vector3, v: THREE.Vector3, w: THREE.Vector3}} The basis vectors.
 */
export const makeBasis = (orientation, normal) => {
  let refAxis = Daydream.X_AXIS;
  if (Math.abs(normal.dot(refAxis)) > 0.9999) {
    refAxis = Daydream.Y_AXIS;
  }
  let v = vectorPool.acquire().copy(normal).applyQuaternion(orientation).normalize();
  let ref = _tempVec.copy(refAxis).applyQuaternion(orientation).normalize();
  let u = vectorPool.acquire().crossVectors(v, ref).normalize();
  let w = vectorPool.acquire().crossVectors(v, u).normalize();
  return { u, v, w };
};

export const Plot = {
  Point: class {
    /**
     * Draws a single dot at a given vector.
     * @param {Object} pipeline - The render pipeline.
     * @param {THREE.Vector3} v - The vector position (normalized).
     * @param {Function} colorFn - Function to determine the color (takes vector and t=0).
     */
    static draw(pipeline, v, colorFn) {
      const c = colorFn(v, 0);
      const color = c.isColor ? c : (c.color || c);
      const alpha = c.alpha !== undefined ? c.alpha : 1.0;
      pipeline.plot(v, color, 0, alpha);
    }
  },

  Path: class {
    /**
     * Draws a sequence of points along a Path object.
     * @param {Object} pipeline - The render pipeline.
     * @param {Path|ProceduralPath} path - The path object.
     * @param {Function} colorFn - Function to determine the color (takes normalized time t).
     */
    static draw(pipeline, path, colorFn) {
      for (let t = 0; t < path.length(); t++) {
        const v = path.getPoint(t / path.length());
        const c = colorFn(t);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(v, color, 0, alpha);
      }
    }
  },

  Line: class {
    static draw(pipeline, v1, v2, colorFn, start = 0, end = 1, longWay = false, omitLast = false) {
      let u = vectorPool.acquire().copy(v1);
      let v = vectorPool.acquire().copy(v2);
      let a = angleBetween(u, v);
      let w = vectorPool.acquire();
      if (Math.abs(a) < 0.0001) { return; }

      if (Math.abs(Math.PI - a) < 0.0001) {
        if (Math.abs(u.dot(Daydream.X_AXIS)) > 0.9999) w.crossVectors(u, Daydream.Y_AXIS).normalize();
        else w.crossVectors(u, Daydream.X_AXIS).normalize();
      } else {
        w.crossVectors(u, v).normalize();
      }

      if (longWay) {
        a = TWO_PI - a;
        w.negate();
      }

      // Start offset
      if (start !== 0) {
        const startAngle = start * a;
        const q = quaternionPool.acquire().setFromAxisAngle(w, startAngle);
        u.applyQuaternion(q).normalize();
      }
      a *= Math.abs(end - start);

      // Simulate seam
      // u(theta).y = uStart.y * cos(theta) + tangent.y * sin(theta)
      const uStart_y = u.y;
      const tangent_y = w.z * u.x - w.x * u.z;
      let simAngle = 0;
      const steps = [];
      const baseStep = TWO_PI / Daydream.W;
      while (simAngle < a) {
        // Height
        const cosT = Math.cos(simAngle);
        const sinT = Math.sin(simAngle);
        const currentY = uStart_y * cosT + tangent_y * sinT;

        // Adaptive Step
        const scaleFactor = Math.max(0.05, Math.sqrt(Math.max(0, 1.0 - currentY * currentY)));
        const step = baseStep * scaleFactor;

        steps.push(step);
        simAngle += step;
      }

      // Normalize
      let scale = a / simAngle;
      let currentAngle = 0;
      const startC = colorFn(u, 0);
      const startColor = startC.isColor ? startC : (startC.color || startC);
      const startAlpha = startC.alpha !== undefined ? startC.alpha : 1.0;
      pipeline.plot(u, startColor, 0, startAlpha);
      const loopLimit = omitLast ? steps.length - 1 : steps.length;
      for (let i = 0; i < loopLimit; i++) {
        const step = steps[i] * scale;
        const q = quaternionPool.acquire().setFromAxisAngle(w, step);
        u.applyQuaternion(q).normalize();
        currentAngle += step;
        const t = (a > 0) ? (currentAngle / a) : 1;
        const c = colorFn(u, t);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(u, color, 0, alpha);
      }
    }
  },

  Vertices: class {
    /**
     * Draws a set of vertices as individual dots.
     * @param {Object} pipeline - The render pipeline.
     * @param {number[][]} vertices - An array of [x, y, z] arrays.
     * @param {Function} colorFn - Function to determine the color (takes vector).
     */
    static draw(pipeline, vertices, colorFn) {
      let v = vectorPool.acquire();
      for (const vertex of vertices) {
        v.set(vertex[0], vertex[1], vertex[2]);
        const c = colorFn(v);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(v, color, 0, alpha);
      }
    }
  },

  Polyhedron: class {
    /**
     * Samples points for the edges of a polyhedron.
     * @param {number[][]} vertices - An array of [x, y, z] vertex arrays.
     * @param {number[][]} edges - An adjacency list of vertex indices.
     * @returns {THREE.Vector3[]} An array of points forming the edges.
     */
    static sample(vertices, edges) {
      let points = [];
      edges.map((adj, i) => {
        adj.map((j) => {
          // Push vertices
          points.push(vectorPool.acquire().set(...vertices[i]).normalize());
          points.push(vectorPool.acquire().set(...vertices[j]).normalize());
        })
      });
      return points;
    }

    /**
     * Draws the edges of a polyhedron by drawing lines between connected vertices.
     * @param {Object} pipeline - The render pipeline.
     * @param {number[][]} vertices - An array of [x, y, z] vertex arrays.
     * @param {number[][]} edges - An adjacency list of vertex indices.
     * @param {Function} colorFn - Function to determine the color (takes vector and normalized progress t).
     */
    static draw(pipeline, vertices, edges, colorFn) {
      edges.map((adj, i) => {
        adj.map((j) => {
          if (i < j) {
            Plot.Line.draw(
              pipeline,
              vectorPool.acquire().set(...vertices[i]).normalize(),
              vectorPool.acquire().set(...vertices[j]).normalize(),
              colorFn);
          }
        })
      });
    }
  },

  Mesh: class {
    /**
     * Draws a wireframe mesh.
     * @param {Object} pipeline - Render pipeline.
     * @param {Object} mesh - The mesh object {vertices: Vector3[], faces: number[][]}.
     * @param {Function} colorFn - Color function.
     */
    static draw(pipeline, mesh, colorFn) {
      const drawn = new Set();
      for (const face of mesh.faces) {
        for (let i = 0; i < face.length; i++) {
          const idx1 = face[i];
          const idx2 = face[(i + 1) % face.length];

          // Deduplicate
          const key = idx1 < idx2 ? `${idx1},${idx2}` : `${idx2},${idx1}`;
          if (drawn.has(key)) continue;
          drawn.add(key);

          Plot.Line.draw(
            pipeline,
            mesh.vertices[idx1],
            mesh.vertices[idx2],
            colorFn
          );
        }
      }
    }
  },

  Ring: class {
    /**
     * Calculates a point on a circle that lies on the surface of the unit sphere.
     * @param {number} a - Angle.
     * @param {number} radius - Radius.
     * @param {THREE.Vector3} u - Basis U.
     * @param {THREE.Vector3} v - Basis V (Normal).
     * @param {THREE.Vector3} w - Basis W.
     * @returns {THREE.Vector3} Point.
     */
    static calcPoint(a, radius, u, v, w) {
      let d = Math.sqrt(Math.pow(1 - radius, 2));
      return vectorPool.acquire().set(
        d * v.x + radius * u.x * Math.cos(a) + radius * w.x * Math.sin(a),
        d * v.y + radius * u.y * Math.cos(a) + radius * w.y * Math.sin(a),
        d * v.z + radius * u.z * Math.cos(a) + radius * w.z * Math.sin(a)
      ).normalize();
    }

    /**
     * Samples points for a polygon or ring on the sphere surface.
     * @param {THREE.Quaternion} orientationQuaternion - The orientation of the ring.
     * @param {THREE.Vector3} normal - The normal vector defining the ring plane.
     * @param {number} radius - The radius of the ring.
     * @param {number} numSamples - The number of points to sample.
     * @param {number} [phase=0] - Starting phase.
     * @returns {THREE.Vector3[]} An array of points.
     */
    static sample(basis, radius, numSamples, phase = 0) {
      const { u, v, w } = basis;
      // Backside
      let vDir = v.clone();
      if (radius > 1) {
        vDir.negate();
        radius = 2 - radius;
      }

      const thetaEq = radius * (Math.PI / 2);
      const r = Math.sin(thetaEq);
      const d = Math.cos(thetaEq);

      // Calculate Samples
      const step = TWO_PI / numSamples;
      let points = [];
      let uTemp = vectorPool.acquire();

      for (let i = 0; i < numSamples; i++) {
        let theta = i * step;
        let t = theta + phase;
        let cosRing = Math.cos(t);
        let sinRing = Math.sin(t);
        uTemp.copy(u).multiplyScalar(cosRing).addScaledVector(w, sinRing);
        let p = vectorPool.acquire().copy(vDir).multiplyScalar(d).addScaledVector(uTemp, r).normalize();
        points.push(p);
      }
      return points;
    }

    /**
     * Draws a circular ring on the sphere surface with adaptive sampling.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientationQuaternion - The orientation of the ring.
     * @param {THREE.Vector3} normal - The normal vector defining the ring plane.
     * @param {number} radius - The radius of the ring.
     * @param {Function} colorFn - Function to determine color.
     * @param {number} [phase=0] - Starting phase.
     */
    static draw(pipeline, basis, radius, colorFn, phase = 0) {
      const points = Plot.Ring.sample(basis, radius, Daydream.W / 4, phase);
      Plot.rasterize(pipeline, points, colorFn, true);
    }
  },

  PlanarLine: class {
    /**
     * Draws a line that is straight in the Azimuthal Equidistant projection centered at 'center'.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Vector3} v1 - Start point (normalized).
     * @param {THREE.Vector3} v2 - End point (normalized).
     * @param {THREE.Vector3} center - Center of projection (normalized).
     * @param {Function} colorFn - (t) => {color, alpha}.
     */
    static draw(pipeline, v1, v2, center, colorFn) {
      // Basis
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(center.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }
      const v = center.clone(); // The 'pole'
      const ref = Math.abs(v.dot(Daydream.X_AXIS)) > 0.9 ? Daydream.Y_AXIS : Daydream.X_AXIS;
      const u = vectorPool.acquire().crossVectors(v, ref).normalize();
      const w = vectorPool.acquire().crossVectors(v, u).normalize();

      const project = (p) => {
        const R = angleBetween(p, v);
        if (R < 0.0001) return new THREE.Vector2(0, 0);
        const x = p.dot(u);
        const y = p.dot(w);
        const theta = Math.atan2(y, x);
        return new THREE.Vector2(R * Math.cos(theta), R * Math.sin(theta));
      };

      const p1 = project(v1);
      const p2 = project(v2);

      const dist = p1.distanceTo(p2);
      const numSteps = Math.max(2, Math.ceil(dist * Daydream.W / (TWO_PI)));

      let pTemp = vectorPool.acquire();

      for (let i = 0; i < numSteps; i++) {
        const t = i / (numSteps - 1);
        const Px = p1.x + (p2.x - p1.x) * t;
        const Py = p1.y + (p2.y - p1.y) * t;

        const R = Math.sqrt(Px * Px + Py * Py);
        const theta = Math.atan2(Py, Px);

        let point = vectorPool.acquire().copy(v);
        if (R > 0.0001) {
          const sinR = Math.sin(R);
          const cosR = Math.cos(R);
          const cosT = Math.cos(theta);
          const sinT = Math.sin(theta);

          // dir = u*cosT + w*sinT
          const dir = vectorPool.acquire().copy(u).multiplyScalar(cosT).addScaledVector(w, sinT).normalize();
          // p = v*cosR + dir*sinR
          point.multiplyScalar(cosR).addScaledVector(dir, sinR).normalize();
        }

        const c = colorFn(t);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(point, color, 0, alpha);
      }
    }
  },

  Polygon: class {
    /**
     * Draws a polygon on the sphere surface.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientationQuaternion - The orientation of the polygon.
     * @param {THREE.Vector3} normal - The normal vector.
     * @param {number} radius - The radius.
     * @param {number} numSides - Number of sides.
     * @param {Function} colorFn - Function to determine color.
     * @param {number} [phase=0] - Starting phase.
     */
    static draw(pipeline, basis, radius, numSides, colorFn, phase = 0) {
      const points = Plot.Polygon.sample(basis, radius, numSides, phase);
      let center = basis.v;
      if (radius > 1.0) {
        center = vectorPool.acquire().copy(basis.v).negate();
      }

      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        Plot.PlanarLine.draw(pipeline, p1, p2, center, (t) => colorFn(p1, t));
      }
    }

    static sample(basis, radius, numSides, phase = 0) {
      // Offset sectors
      const offset = Math.PI / numSides;
      return Plot.Ring.sample(basis, radius, numSides, phase + offset);
    }
  },

  Star: class {
    static sample(basis, radius, numSides, phase = 0) {
      // Basis
      let { v, u, w } = basis;

      if (radius > 1.0) {
        v = vectorPool.acquire().copy(v).negate();
        u = vectorPool.acquire().copy(u).negate();
        radius = 2.0 - radius;
      }

      const outerRadius = radius * (Math.PI / 2);
      const innerRadius = outerRadius * 0.382;

      const points = [];
      const angleStep = Math.PI / numSides;

      for (let i = 0; i < numSides * 2; i++) {
        const theta = phase + i * angleStep;
        const r = (i % 2 === 0) ? outerRadius : innerRadius;

        const sinR = Math.sin(r);
        const cosR = Math.cos(r);
        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);

        const p = vectorPool.acquire()
          .copy(v).multiplyScalar(cosR)
          .addScaledVector(u, cosT * sinR)
          .addScaledVector(w, sinT * sinR)
          .normalize();

        points.push(p);
      }
      return points;
    }

    static draw(pipeline, basis, radius, numSides, colorFn, phase = 0) {
      const points = Plot.Star.sample(basis, radius, numSides, phase);

      let center = basis.v;
      if (radius > 1.0) {
        center = vectorPool.acquire().copy(basis.v).negate();
      }

      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        Plot.PlanarLine.draw(pipeline, p1, p2, center, (t) => colorFn(p1, t));
      }
    }
  },

  Flower: class {
    static sample(basis, radius, numSides, phase = 0) {
      let { v, u, w } = basis;

      if (radius > 1.0) {
        // Antipode basis
        v = vectorPool.acquire().copy(v).negate();
        u = vectorPool.acquire().copy(u).negate();

        radius = 2.0 - radius;
      }

      // Draw boundary relative to antipode
      const desiredOuterRadius = radius * (Math.PI / 2);
      const apothem = Math.PI - desiredOuterRadius;
      const angleStep = Math.PI / numSides;

      const points = [];
      const numSegments = Math.max(2, Math.floor(Daydream.W / numSides)); // Resolution per side

      // Sample boundary: R(phi) = apothem / cos(phi)
      for (let i = 0; i < numSides; i++) {
        const sectorCenter = phase + i * 2 * angleStep;

        for (let j = 0; j < numSegments; j++) {
          const t = j / numSegments;
          const localPhi = -angleStep + t * (2 * angleStep);
          let R = apothem / Math.cos(localPhi);
          if (R > Math.PI) R = Math.PI;


          // Convert Polar (R, theta)
          const sinR = Math.sin(R);
          const cosR = Math.cos(R);
          const cosT = Math.cos(theta);
          const sinT = Math.sin(theta);

          const p = vectorPool.acquire()
            .copy(v).multiplyScalar(cosR)
            .addScaledVector(u, cosT * sinR)
            .addScaledVector(w, sinT * sinR)
            .normalize();

          points.push(p);
        }
      }

      // Close loop
      if (points.length > 0) {
        points.push(vectorPool.acquire().copy(points[0]));
      }

      return points;
    }

    static draw(pipeline, basis, radius, numSides, colorFn, phase = 0) {
      const points = Plot.Flower.sample(basis, radius, numSides, phase);
      Plot.rasterize(pipeline, points, colorFn, false);
    }
  },

  DistortedRing: class {


    /**
     * Calculates a single point on a sphere distorted by a function.
     * @param {Function} f - The shift function.
     * @param {THREE.Vector3} normal - The normal.
     * @param {number} radius - The base radius.
     * @param {number} angle - The angle.
     */
    static point(f, basis, radius, angle) { // f, basis, radius, angle
      let { u, v, w } = basis;

      if (radius > 1) {
        // Flip basis
        v = vectorPool.acquire().copy(v).negate();
        u = vectorPool.acquire().copy(u).negate();
        radius = 2 - radius;
      }

      let vi = Plot.Ring.calcPoint(angle, radius, u, v, w);
      let vp = Plot.Ring.calcPoint(angle, 1, u, v, w);
      let axis = vectorPool.acquire().crossVectors(v, vp).normalize();
      let shift = new THREE.Quaternion().setFromAxisAngle(axis, f(angle * Math.PI / 2));
      return vi.applyQuaternion(shift);
    }

    /**
     * Samples points for a function-distorted ring.
     * @param {THREE.Quaternion} orientationQuaternion - Orientation.
     * @param {THREE.Vector3} normal - Normal.
     * @param {number} radius - Radius.
     * @param {Function} shiftFn - Shift function.
     * @param {number} [phase=0] - Phase.
     */
    static sample(basis, radius, shiftFn, phase = 0) {
      // Basis
      const { v, u, w } = basis;

      // Backside
      let vSign = 1.0;
      if (radius > 1) {
        vSign = -1.0;
        radius = 2 - radius;
      }

      // Projection
      const thetaEq = radius * (Math.PI / 2);
      const r = Math.sin(thetaEq);
      const d = Math.cos(thetaEq);

      // Calculate Samples
      const numSamples = Daydream.W;
      const step = TWO_PI / numSamples;
      let points = [];
      let uTemp = vectorPool.acquire();

      for (let i = 0; i < numSamples; i++) {
        let theta = i * step;
        let t = theta + phase;
        let cosRing = Math.cos(t);
        let sinRing = Math.sin(t);
        uTemp.copy(u).multiplyScalar(cosRing).addScaledVector(w, sinRing);

        // Shift
        let shift = shiftFn(theta / (TWO_PI));
        let cosShift = Math.cos(shift);
        let sinShift = Math.sin(shift);
        let vScale = (vSign * d) * cosShift - r * sinShift;
        let uScale = r * cosShift + (vSign * d) * sinShift;
        let p = vectorPool.acquire().copy(v).multiplyScalar(vScale).addScaledVector(uTemp, uScale).normalize();

        points.push(p);
      }

      return points;
    }

    /**
     * Draws a function-distorted ring.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientationQuaternion - Orientation.
     * @param {THREE.Vector3} normal - Normal.
     * @param {number} radius - Radius.
     * @param {Function} shiftFn - Shift function.
     * @param {Function} colorFn - Color function.
     * @param {number} [phase=0] - Phase.
     */
    static draw(pipeline, basis, radius, shiftFn, colorFn, phase = 0) {
      const points = Plot.DistortedRing.sample(basis, radius, shiftFn, phase);
      Plot.rasterize(pipeline, points, colorFn, true);
    }
  },

  Spiral: class {

    /**
     * Samples points forming a Fibonacci spiral pattern.
     * @param {number} n - Total number of points.
     * @param {number} eps - Epsilon value for spiral offset.
     * @returns {THREE.Vector3[]} An array of points.
     */
    static sample(n, eps) {
      const points = [];
      for (let i = 0; i < n; ++i) {
        points.push(fibSpiral(n, eps, i));
      }
      return points;
    }

    /**
     * Draws points forming a Fibonacci spiral pattern.
     * @param {Object} pipeline - Render pipeline.
     * @param {number} n - Total number of points.
     * @param {number} eps - Epsilon value for spiral offset.
     * @param {Function} colorFn - Function to determine the color (takes vector).
     */
    static draw(pipeline, n, eps, colorFn) {
      const points = Plot.Spiral.sample(n, eps);
      for (const v of points) {
        const c = colorFn(v);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(v, color, 0, alpha);
      }
    }
  },

  /**
   * Rasterizes a list of points into Dot objects by connecting them with geodesic lines.
   * @param {Object} pipeline - The render pipeline.
   * @param {THREE.Vector3[]} points - The list of points.
   * @param {Function} colorFn - Function to determine color (takes vector and normalized progress t).
   * @param {boolean} [closeLoop=false] - If true, connects the last point to the first.
   */
  rasterize: (pipeline, points, colorFn, closeLoop = false) => {
    const len = points.length;
    if (len === 0) return;

    const count = closeLoop ? len : len - 1;
    for (let i = 0; i < count; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % len];

      const segmentColorFn = (p, subT) => {
        const globalT = (i + subT) / count;
        return colorFn(p, globalT);
      };

      // Draw segment
      const omitLast = closeLoop || (i < count - 1);
      Plot.Line.draw(pipeline, p1, p2, segmentColorFn, 0, 1, false, omitLast);
    }
  }

};

export const SDF = {
  Ring: class {
    /**
     * @param {Object} basis - {u, v, w}.
     * @param {number} radius - Radius.
     * @param {number} thickness - Thickness.
     * @param {number} phase - Phase.
     */
    constructor(basis, radius, thickness, phase = 0) {
      this.basis = basis;
      this.radius = radius;
      this.thickness = thickness;
      this.phase = phase;

      const { v, u, w } = basis;
      this.normal = v;
      this.u = u;
      this.w = w;

      this.nx = v.x;
      this.ny = v.y;
      this.nz = v.z;

      this.targetAngle = radius * (Math.PI / 2);
      this.centerPhi = Math.acos(this.ny);

      // Optimize
      const angMin = Math.max(0, this.targetAngle - thickness);
      const angMax = Math.min(Math.PI, this.targetAngle + thickness);
      this.cosMax = Math.cos(angMin);
      this.cosMin = Math.cos(angMax);

      this.cosTarget = Math.cos(this.targetAngle);
      const safeApprox = (this.targetAngle > 0.05 && this.targetAngle < Math.PI - 0.05);
      this.invSinTarget = safeApprox ? (1.0 / Math.sin(this.targetAngle)) : 0;
    }

    /**
     * Calculates the vertical range of the ring on the screen.
     * @returns {{yMin: number, yMax: number}} The vertical bounds [yMin, yMax].
     */
    getVerticalBounds() {
      // Vertical
      const a1 = this.centerPhi - this.targetAngle;
      const a2 = this.centerPhi + this.targetAngle;

      let phiMin = 0;
      let phiMax = Math.PI;

      if (a1 <= 0) {
        phiMin = 0;
      } else {
        const p1 = Math.acos(Math.cos(a1));
        const p2 = Math.acos(Math.cos(a2));
        phiMin = Math.min(p1, p2);
      }

      if (a2 >= Math.PI) {
        phiMax = Math.PI;
      } else {
        const p1 = Math.acos(Math.cos(a1));
        const p2 = Math.acos(Math.cos(a2));
        phiMax = Math.max(p1, p2);
      }

      let finalPhiMin = Math.max(0, phiMin - this.thickness);
      let finalPhiMax = Math.min(Math.PI, phiMax + this.thickness);

      if (this.basis.limits) {
        finalPhiMin = Math.max(finalPhiMin, this.basis.limits.minPhi);
        finalPhiMax = Math.min(finalPhiMax, this.basis.limits.maxPhi);
      }

      const yMin = Math.max(0, Math.floor((finalPhiMin * (Daydream.H - 1)) / Math.PI));
      const yMax = Math.min(Daydream.H - 1, Math.ceil((finalPhiMax * (Daydream.H - 1)) / Math.PI));

      return { yMin, yMax };
    }

    /**
     * @param {number} y 
     * @returns {{start: number, end: number}[]|null}
     */
    getHorizontalBounds(y) {
      const phi = yToPhi(y);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);

      const R = Math.sqrt(this.nx * this.nx + this.nz * this.nz);
      // Check poles
      if (R < 0.01) return null;

      const denom = R * sinPhi;
      if (Math.abs(denom) < 0.000001) return null;

      const alpha = Math.atan2(this.nx, this.nz);

      const D_max = this.cosMax; // cos(ang_low)
      const D_min = this.cosMin; // cos(ang_high)

      const C_min = (D_min - this.ny * cosPhi) / denom;
      const C_max = (D_max - this.ny * cosPhi) / denom;

      const minCos = Math.max(-1, C_min);
      const maxCos = Math.min(1, C_max);

      if (minCos > maxCos) return []; // Empty row

      const angleMin = Math.acos(maxCos);
      const angleMax = Math.acos(minCos);

      const pixelWidth = 2 * Math.PI / Daydream.W;
      const safeThreshold = pixelWidth;

      const intervals = [];

      const addWindow = (t1, t2) => {
        const x1 = Math.floor((t1 * Daydream.W) / (2 * Math.PI));
        const x2 = Math.ceil((t2 * Daydream.W) / (2 * Math.PI));
        if (x2 - x1 >= Daydream.W) return null; // Full row
        intervals.push({ start: x1, end: x2 });
        return intervals;
      };

      if (angleMin <= safeThreshold) {
        if (!addWindow(alpha - angleMax, alpha + angleMax)) return null;
      } else if (angleMax >= Math.PI - safeThreshold) {
        if (!addWindow(alpha + angleMin, alpha + 2 * Math.PI - angleMin)) return null;
      } else {
        addWindow(alpha - angleMax, alpha - angleMin);
        addWindow(alpha + angleMin, alpha + angleMax);
      }

      return intervals;
    }

    /**
     * Calculates the signed distance from a point to the ring surface.
     * @param {THREE.Vector3} p - The point to check.
     * @param {{dist: number, t: number, rawDist: number}} [out] - Result object.
     * @returns {{dist: number, t: number, rawDist: number}} The distance result.
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      const dot = p.dot(this.normal);
      if (dot < this.cosMin || dot > this.cosMax) {
        out.dist = 100.0;
        return out;
      }

      let dist = 0;
      if (this.invSinTarget !== 0) {
        // Approx
        dist = Math.abs(dot - this.cosTarget) * this.invSinTarget;
      } else {
        const polarAngle = Math.acos(Math.max(-1, Math.min(1, dot)));
        dist = Math.abs(polarAngle - this.targetAngle);
      }

      // Calculate t (azimuth)
      const dotU = p.dot(this.u);
      const dotW = p.dot(this.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;
      azimuth += this.phase;
      const t = azimuth / (2 * Math.PI);

      out.dist = dist - this.thickness;
      out.t = t;
      out.rawDist = dist;

      return out;
    }
  },

  DistortedRing: class {
    /**
     * @param {Object} basis - {u, v, w}.
     * @param {number} radius - Radius.
     * @param {number} thickness - Thickness.
     * @param {Function} shiftFn - Shift.
     * @param {number} maxDistortion - Max shift.
     * @param {number} phase - Phase.
     */
    constructor(basis, radius, thickness, shiftFn, maxDistortion, phase = 0) {
      this.basis = basis;
      this.radius = radius; // Base angular radius
      this.thickness = thickness;
      this.shiftFn = shiftFn;
      this.maxDistortion = maxDistortion;
      this.phase = phase;

      const { v, u, w } = basis;
      this.normal = v;
      this.u = u;
      this.w = w;

      this.nx = v.x;
      this.ny = v.y;
      this.nz = v.z;

      this.targetAngle = radius * (Math.PI / 2);
      this.centerPhi = Math.acos(this.ny);
      // Max thickness
      this.maxThickness = thickness + maxDistortion;
    }

    /**
     * Calculates the vertical range.
     * @returns {{yMin: number, yMax: number}} Vertical bounds.
     */
    getVerticalBounds() {
      const a1 = this.centerPhi - this.targetAngle;
      const a2 = this.centerPhi + this.targetAngle;

      let phiMin = 0;
      let phiMax = Math.PI;

      if (a1 <= 0) phiMin = 0;
      else {
        const p1 = Math.acos(Math.cos(a1));
        const p2 = Math.acos(Math.cos(a2));
        phiMin = Math.min(p1, p2);
      }

      if (a2 >= Math.PI) phiMax = Math.PI;
      else {
        const p1 = Math.acos(Math.cos(a1));
        const p2 = Math.acos(Math.cos(a2));
        phiMax = Math.max(p1, p2);
      }

      let finalPhiMin = Math.max(0, phiMin - this.maxThickness);
      let finalPhiMax = Math.min(Math.PI, phiMax + this.maxThickness);

      const yMin = Math.max(0, Math.floor((finalPhiMin * (Daydream.H - 1)) / Math.PI));
      const yMax = Math.min(Daydream.H - 1, Math.ceil((finalPhiMax * (Daydream.H - 1)) / Math.PI));

      return { yMin, yMax };
    }

    /**
     * Calculates horizontal intervals for a scanline.
     * @param {number} y - Scanline y.
     * @returns {{start: number, end: number}[]|null} Intervals.
     */
    getHorizontalBounds(y) {
      const phi = yToPhi(y);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);

      const ang_low = Math.max(0, this.targetAngle - this.maxThickness);
      const ang_high = Math.min(Math.PI, this.targetAngle + this.maxThickness);
      const D_max = Math.cos(ang_low);
      const D_min = Math.cos(ang_high);

      const R = Math.sqrt(this.nx * this.nx + this.nz * this.nz);
      if (R < 0.01) return null;

      const denom = R * sinPhi;
      if (Math.abs(denom) < 0.000001) return null;

      const C_min = (D_min - this.ny * cosPhi) / denom;
      const C_max = (D_max - this.ny * cosPhi) / denom;

      const minCos = Math.max(-1, C_min);
      const maxCos = Math.min(1, C_max);

      if (minCos > maxCos) return [];

      const angleMin = Math.acos(maxCos);
      const angleMax = Math.acos(minCos);

      const pixelWidth = 2 * Math.PI / Daydream.W;
      const safeThreshold = pixelWidth;
      const alpha = Math.atan2(this.nx, this.nz);

      const intervals = [];
      const addWindow = (t1, t2) => {
        const x1 = Math.floor((t1 * Daydream.W) / (2 * Math.PI));
        const x2 = Math.ceil((t2 * Daydream.W) / (2 * Math.PI));
        if (x2 - x1 >= Daydream.W) return null;
        intervals.push({ start: x1, end: x2 });
        return intervals;
      };

      if (angleMin <= safeThreshold) {
        if (!addWindow(alpha - angleMax, alpha + angleMax)) return null;
      } else if (angleMax >= Math.PI - safeThreshold) {
        if (!addWindow(alpha + angleMin, alpha + 2 * Math.PI - angleMin)) return null;
      } else {
        addWindow(alpha - angleMax, alpha - angleMin);
        addWindow(alpha + angleMin, alpha + angleMax);
      }
      return intervals;
    }

    /**
     * Signed distance to the distorted ring.
     * @param {THREE.Vector3} p - Point.
     * @param {{dist: number, t: number, rawDist: number}} [out] - Result.
     * @returns {{dist: number, t: number, rawDist: number}} Result.
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      const polarAngle = angleBetween(p, this.normal);

      const dotU = p.dot(this.u);
      const dotW = p.dot(this.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;

      const t = azimuth + this.phase;
      const normT = t / (2 * Math.PI);

      const shift = this.shiftFn(normT);
      const localTarget = this.targetAngle + shift;

      const dist = Math.abs(polarAngle - localTarget);

      out.dist = dist - this.thickness;
      out.t = (azimuth / (2 * Math.PI));
      out.rawDist = dist;
      return out;
    }
  },

  Union: class {
    /**
     * @param {Object} a - Shape A.
     * @param {Object} b - Shape B.
     */
    constructor(a, b) {
      this.a = a;
      this.b = b;
      this.thickness = Math.max(a.thickness || 0, b.thickness || 0);
    }

    /**
     * Vertical bounds of the union.
     * @returns {{yMin: number, yMax: number}} Bounds.
     */
    getVerticalBounds() {
      const b1 = this.a.getVerticalBounds();
      const b2 = this.b.getVerticalBounds();
      return {
        yMin: Math.min(b1.yMin, b2.yMin),
        yMax: Math.max(b1.yMax, b2.yMax)
      };
    }

    /**
     * Distance to union (min of distances).
     * @param {THREE.Vector3} p - Point.
     * @param {{dist: number, t: number, rawDist: number}} [out] - Result.
     * @returns {{dist: number, t: number, rawDist: number}} Result.
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      const d1 = this.a.distance(p, out);
      const resA = this.a.distance(p);
      const resB = this.b.distance(p);

      if (resA.dist < resB.dist) {
        out.dist = resA.dist;
        out.t = resA.t;
        out.rawDist = resA.rawDist;
      } else {
        out.dist = resB.dist;
        out.t = resB.t;
        out.rawDist = resB.rawDist;
      }
      return out;
    }
  },

  Subtract: class {
    /**
     * @param {Object} a - Shape A.
     * @param {Object} b - Shape B.
     */
    constructor(a, b) {
      this.a = a;
      this.b = b;
      this.thickness = a.thickness || 0;
    }

    /**
     * Vertical bounds of the subtraction (conservatively A's bounds).
     * @returns {{yMin: number, yMax: number}} Bounds.
     */
    getVerticalBounds() {
      return this.a.getVerticalBounds();
    }

    /**
     * Horizontal bounds (delegates to A).
     * @param {number} y - Scanline.
     * @returns {{start: number, end: number}[]|null} Intervals.
     */
    // Conservative
    getHorizontalBounds(y) {
      if (this.a.getHorizontalBounds) return this.a.getHorizontalBounds(y);
      return null;
    }

    /**
     * Distance to subtraction (max of A and -B).
     * @param {THREE.Vector3} p - Point.
     * @param {{dist: number, t: number, rawDist: number}} [out] - Result.
     * @returns {{dist: number, t: number, rawDist: number}} Result.
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      const resA = this.a.distance(p);
      const resB = this.b.distance(p);

      const dist = Math.max(resA.dist, -resB.dist);

      if (resA.dist > -resB.dist) {
        out.dist = dist;
        out.t = resA.t;
        out.rawDist = resA.rawDist; // Preserve A's attributes?
      } else {
        // If B is the boundary, we are "inside" B (subtracted space).
        out.dist = dist;
        out.t = resB.t;
        out.rawDist = resB.dist;
      }
      return out;
    }
  },

  Intersection: class {
    /**
     * @param {Object} a - Shape A.
     * @param {Object} b - Shape B.
     */
    constructor(a, b) {
      this.a = a;
      this.b = b;
      this.thickness = Math.min(a.thickness || 0, b.thickness || 0);
    }

    /**
     * Vertical bounds of intersection.
     * @returns {{yMin: number, yMax: number}} Bounds.
     */
    getVerticalBounds() {
      const b1 = this.a.getVerticalBounds();
      const b2 = this.b.getVerticalBounds();
      return {
        yMin: Math.max(b1.yMin, b2.yMin),
        yMax: Math.min(b1.yMax, b2.yMax)
      };
    }

    /**
     * Horizontal bounds of intersection.
     * @param {number} y - Scanline.
     * @returns {{start: number, end: number}[]|null} Intervals.
     */
    // Intersect
    getHorizontalBounds(y) {
      let iA = this.a.getHorizontalBounds ? this.a.getHorizontalBounds(y) : null;
      let iB = this.b.getHorizontalBounds ? this.b.getHorizontalBounds(y) : null;

      // Full row
      if (iA === null) return iB;
      if (iB === null) return iA;

      // If either returns an empty list (no intersection), the result is empty.
      if (iA.length === 0 || iB.length === 0) return [];

      let result = [];
      let idxA = 0;
      let idxB = 0;

      // Assuming sorted intervals from children (standard for Scan)
      while (idxA < iA.length && idxB < iB.length) {
        let intA = iA[idxA];
        let intB = iB[idxB];

        // Find overlap
        let start = Math.max(intA.start, intB.start);
        let end = Math.min(intA.end, intB.end);

        if (start < end) {
          result.push({ start, end });
        }

        // Advance the one that ends first
        if (intA.end < intB.end) {
          idxA++;
        } else {
          idxB++;
        }
      }
      return result;
    }

    /**
     * Distance to intersection (max of distances).
     * @param {THREE.Vector3} p - Point.
     * @param {{dist: number, t: number, rawDist: number}} [out] - Result.
     * @returns {{dist: number, t: number, rawDist: number}} Result.
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      const resA = this.a.distance(p);
      const resB = this.b.distance(p);

      if (resA.dist > resB.dist) {
        out.dist = resA.dist;
        out.t = resA.t;
        out.rawDist = resA.rawDist;
      } else {
        out.dist = resB.dist;
        out.t = resB.t;
        out.rawDist = resB.rawDist;
      }
      return out;
    }
  },

  Polygon: class {
    /**
     * @param {Object} basis - {u, v, w}.
     * @param {number} radius - Radius.
     * @param {number} thickness - Thickness.
     * @param {number} sides - Sides.
     * @param {number} phase - Phase.
     */
    constructor(basis, radius, thickness, sides, phase = 0) {
      this.basis = basis;
      this.thickness = thickness;
      this.sides = sides;
      this.phase = phase;
      this.apothem = thickness * Math.cos(Math.PI / sides);

      this.nx = basis.v.x;
      this.ny = basis.v.y;
      this.nz = basis.v.z;
      this.R = Math.sqrt(this.nx * this.nx + this.nz * this.nz);
      this.alpha = Math.atan2(this.nx, this.nz);

      const centerPhi = Math.acos(Math.max(-1, Math.min(1, basis.v.y)));
      const margin = thickness + 0.1;
      this.yMin = Math.floor((Math.max(0, centerPhi - margin) / Math.PI) * (Daydream.H - 1));
      this.yMax = Math.ceil((Math.min(Math.PI, centerPhi + margin) / Math.PI) * (Daydream.H - 1));
    }

    /**
     * @returns {{yMin: number, yMax: number}} Vertical bounds.
     */
    getVerticalBounds() { return { yMin: this.yMin, yMax: this.yMax }; }

    /**
     * @param {number} y 
     * @returns {{start: number, end: number}[]|null}
     */
    getHorizontalBounds(y) {
      const phi = yToPhi(y);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);

      if (this.R < 0.01) return null; // Full row (near pole)

      const pixelWidth = 2 * Math.PI / Daydream.W;
      const ang_high = this.thickness + pixelWidth; // Use slightly expanded bounds for AA
      const D_min = Math.cos(ang_high);

      const denom = this.R * sinPhi;
      if (Math.abs(denom) < 0.000001) return null;

      const C_min = (D_min - this.ny * cosPhi) / denom;
      if (C_min > 1.0) return []; // Outside cap
      if (C_min < -1.0) return null; // Full row

      const dAlpha = Math.acos(C_min);
      const t1 = this.alpha - dAlpha;
      const t2 = this.alpha + dAlpha;

      const x1 = Math.floor((t1 * Daydream.W) / (2 * Math.PI));
      const x2 = Math.ceil((t2 * Daydream.W) / (2 * Math.PI));

      if (x2 - x1 >= Daydream.W) return null;

      return [{ start: x1, end: x2 }];
    }

    /**
     * @param {THREE.Vector3} p 
     * @param {{dist: number, t: number, rawDist: number}} [out] 
     * @returns {{dist: number, t: number, rawDist: number}}
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      const polarAngle = angleBetween(p, this.basis.v);
      const dotU = p.dot(this.basis.u);
      const dotW = p.dot(this.basis.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;

      azimuth += this.phase;

      const sectorAngle = 2 * Math.PI / this.sides;
      const localAzimuth = wrap(azimuth + sectorAngle / 2, sectorAngle) - sectorAngle / 2;

      out.dist = polarAngle * Math.cos(localAzimuth) - this.apothem;
      out.t = polarAngle / this.thickness; // Normalized distance for color lookup
      out.rawDist = polarAngle;
      return out;
    }
  },

  Star: class {
    /**
     * @param {Object} basis - {u, v, w}.
     * @param {number} radius - Radius.
     * @param {number} sides - Sides.
     * @param {number} phase - Phase.
     */
    constructor(basis, radius, sides, phase = 0) {
      this.basis = basis;
      this.sides = sides;
      this.phase = phase;

      const outerRadius = radius * (Math.PI / 2);
      const innerRadius = outerRadius * 0.382;
      const angleStep = Math.PI / sides;

      const vT = outerRadius;
      const vVx = innerRadius * Math.cos(angleStep);
      const vVy = innerRadius * Math.sin(angleStep);

      const dx = vVx - vT;
      const dy = vVy;
      const len = Math.sqrt(dx * dx + dy * dy);
      this.nx = -dy / len;
      this.ny = dx / len;
      this.planeD = -(this.nx * vT);
      this.thickness = outerRadius;

      // Scan
      this.scanNy = basis.v.y;
      this.scanNx = basis.v.x;
      this.scanNz = basis.v.z;
      this.scanR = Math.sqrt(this.scanNx * this.scanNx + this.scanNz * this.scanNz);
      this.scanAlpha = Math.atan2(this.scanNx, this.scanNz);

      const centerPhi = Math.acos(Math.max(-1, Math.min(1, basis.v.y)));
      const margin = outerRadius + 0.1;
      this.yMin = Math.floor((Math.max(0, centerPhi - margin) / Math.PI) * (Daydream.H - 1));
      this.yMax = Math.ceil((Math.min(Math.PI, centerPhi + margin) / Math.PI) * (Daydream.H - 1));
    }

    /**
     * @returns {{yMin: number, yMax: number}} Vertical bounds.
     */
    getVerticalBounds() { return { yMin: this.yMin, yMax: this.yMax }; }

    /**
     * @param {number} y 
     * @returns {{start: number, end: number}[]|null}
     */
    getHorizontalBounds(y) {
      // Bounding circle
      const phi = yToPhi(y);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);
      if (this.scanR < 0.01) return null;

      const pixelWidth = 2 * Math.PI / Daydream.W;
      const D_min = Math.cos(this.thickness + pixelWidth);
      const denom = this.scanR * sinPhi;
      if (Math.abs(denom) < 0.000001) return null;

      const C_min = (D_min - this.scanNy * cosPhi) / denom;
      if (C_min > 1.0) return [];
      if (C_min < -1.0) return null;

      const dAlpha = Math.acos(C_min);
      const t1 = this.scanAlpha - dAlpha;
      const t2 = this.scanAlpha + dAlpha;
      const x1 = Math.floor((t1 * Daydream.W) / (2 * Math.PI));
      const x2 = Math.ceil((t2 * Daydream.W) / (2 * Math.PI));
      if (x2 - x1 >= Daydream.W) return null;
      return [{ start: x1, end: x2 }];
    }

    /**
     * @param {THREE.Vector3} p 
     * @param {{dist: number, t: number, rawDist: number}} [out] 
     * @returns {{dist: number, t: number, rawDist: number}}
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      const scanDist = angleBetween(p, this.basis.v);
      const dotU = p.dot(this.basis.u);
      const dotW = p.dot(this.basis.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;

      azimuth += this.phase;

      const sectorAngle = 2 * Math.PI / this.sides;
      let localAzimuth = wrap(azimuth + sectorAngle / 2, sectorAngle) - sectorAngle / 2;
      localAzimuth = Math.abs(localAzimuth);

      const px = scanDist * Math.cos(localAzimuth);
      const py = scanDist * Math.sin(localAzimuth);

      const distToEdge = px * this.nx + py * this.ny + this.planeD;

      out.dist = -distToEdge;
      out.t = scanDist / this.thickness;
      out.rawDist = scanDist;
      return out;
    }
  },

  Flower: class {
    /**
     * @param {Object} basis - {u, v, w}.
     * @param {number} radius - Radius.
     * @param {number} sides - Sides.
     * @param {number} phase - Phase.
     */
    constructor(basis, radius, sides, phase = 0) {
      this.basis = basis;
      this.sides = sides;
      this.phase = phase;

      const desiredOuterRadius = radius * (Math.PI / 2);
      this.apothem = Math.PI - desiredOuterRadius;
      this.thickness = desiredOuterRadius;
      this.antipode = basis.v.clone().negate();

      this.scanNy = this.antipode.y;
      this.scanNx = this.antipode.x;
      this.scanNz = this.antipode.z;
      this.scanR = Math.sqrt(this.scanNx * this.scanNx + this.scanNz * this.scanNz);
      this.scanAlpha = Math.atan2(this.scanNx, this.scanNz);

      const centerPhi = Math.acos(Math.max(-1, Math.min(1, this.antipode.y)));
      const margin = this.thickness + 0.1;
      this.yMin = Math.floor((Math.max(0, centerPhi - margin) / Math.PI) * (Daydream.H - 1));
      this.yMax = Math.ceil((Math.min(Math.PI, centerPhi + margin) / Math.PI) * (Daydream.H - 1));
    }

    /**
     * @returns {{yMin: number, yMax: number}} Vertical bounds.
     */
    getVerticalBounds() { return { yMin: this.yMin, yMax: this.yMax }; }

    /**
     * @param {number} y 
     * @returns {{start: number, end: number}[]|null}
     */
    getHorizontalBounds(y) {
      const phi = yToPhi(y);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);
      if (this.scanR < 0.01) return null;

      const pixelWidth = 2 * Math.PI / Daydream.W;
      const D_min = Math.cos(this.thickness + pixelWidth);
      const denom = this.scanR * sinPhi;
      if (Math.abs(denom) < 0.000001) return null;

      const C_min = (D_min - this.scanNy * cosPhi) / denom;
      if (C_min > 1.0) return [];
      if (C_min < -1.0) return null;

      const dAlpha = Math.acos(C_min);
      const t1 = this.scanAlpha - dAlpha;
      const t2 = this.scanAlpha + dAlpha;
      const x1 = Math.floor((t1 * Daydream.W) / (2 * Math.PI));
      const x2 = Math.ceil((t2 * Daydream.W) / (2 * Math.PI));
      if (x2 - x1 >= Daydream.W) return null;
      return [{ start: x1, end: x2 }];
    }

    /**
     * @param {THREE.Vector3} p 
     * @param {{dist: number, t: number, rawDist: number}} [out] 
     * @returns {{dist: number, t: number, rawDist: number}}
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      const scanDist = angleBetween(p, this.antipode);
      const polarAngle = Math.PI - scanDist;

      const dotU = p.dot(this.basis.u);
      const dotW = p.dot(this.basis.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;

      azimuth += this.phase;

      const sectorAngle = 2 * Math.PI / this.sides;
      const localAzimuth = wrap(azimuth + sectorAngle / 2, sectorAngle) - sectorAngle / 2;

      const distToEdge = polarAngle * Math.cos(localAzimuth) - this.apothem;

      out.dist = -distToEdge;
      out.t = scanDist / this.thickness;
      out.rawDist = scanDist;
      return out;
    }
  },

  Face: class {
    /**
     * @param {THREE.Vector3[]} vertices - Vertices.
     * @param {number} thickness - Thickness.
     */
    constructor(vertices, thickness = 0) {
      this.vertices = vertices;
      this.thickness = thickness;
      this.planes = [];
      this.yMin = Daydream.H;
      this.yMax = 0;
      this.intervals = null;

      // Centroid & Basis
      const center = new THREE.Vector3();
      for (const v of vertices) center.add(v);
      center.normalize();

      this.center = center;
      this.basisV = center; // Normal (V)

      // Basis U W
      let ref = Math.abs(center.dot(Daydream.X_AXIS)) > 0.9 ? Daydream.Y_AXIS : Daydream.X_AXIS;
      this.basisU = new THREE.Vector3().crossVectors(center, ref).normalize();
      this.basisW = new THREE.Vector3().crossVectors(center, this.basisU).normalize();

      // Project 2D
      this.poly2D = [];
      for (const v of vertices) {
        const d = v.dot(this.basisV);
        // u = (v . basisU) / d, w = (v . basisW) / d
        const x = v.dot(this.basisU) / d;
        const y = v.dot(this.basisW) / d;
        this.poly2D.push({ x, y });
      }

      // Inradius
      let minEdgeDist = Infinity;
      const len = this.poly2D.length;
      if (len < 2) {
        minEdgeDist = 1.0;
      } else {
        for (let i = 0; i < len; i++) {
          const p1 = this.poly2D[i];
          const p2 = this.poly2D[(i + 1) % len];

          // Distance from (0,0) to segment p1-p2
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const l2 = dx * dx + dy * dy;
          if (l2 < 1e-12) {
            const d = Math.sqrt(p1.x * p1.x + p1.y * p1.y);
            if (d < minEdgeDist) minEdgeDist = d;
            continue;
          }

          // t = dot(p - p1, p2 - p1) / l2 .  Here p is (0,0) -> dot(-p1, p2-p1)
          let t = - (p1.x * dx + p1.y * dy) / l2;
          t = Math.max(0, Math.min(1, t));

          const closestX = p1.x + t * dx;
          const closestY = p1.y + t * dy;
          const distSq = closestX * closestX + closestY * closestY;

          if (distSq < minEdgeDist) minEdgeDist = distSq;
        }
        minEdgeDist = Math.sqrt(minEdgeDist);
      }
      this.size = (minEdgeDist > 0.0001) ? minEdgeDist : 1.0;

      // Compute Bounds
      let minPhi = 100;
      let maxPhi = -100;
      const thetas = [];

      for (let i = 0; i < this.vertices.length; i++) {
        const v1 = this.vertices[i];
        const v2 = this.vertices[(i + 1) % this.vertices.length];

        // Plane Normal
        // FIXED: Use new THREE.Vector3() instead of pool to avoid corruption
        const normal = new THREE.Vector3().crossVectors(v1, v2);

        // Skip degenerate
        if (normal.lengthSq() < 1e-12) {
          // Skip adding to planes, but continue vertex bounds checks.
        } else {
          normal.normalize();
          this.planes.push(normal);
        }

        // Vertices
        const phi1 = Math.acos(Math.max(-1, Math.min(1, v1.y)));
        if (phi1 < minPhi) minPhi = phi1;
        if (phi1 > maxPhi) maxPhi = phi1;

        // Arc Extrema
        const ny = normal.y;
        if (Math.abs(ny) < 0.99999) { // Avoid pole-aligned planes
          const nx = normal.x;
          const nz = normal.z;
          // P_top = Projection of (0,1,0) onto plane N, normalized.
          // Vector T = ( -nx*ny, 1 - ny*ny, -nz*ny )
          const tx = -nx * ny;
          const ty = 1.0 - ny * ny;
          const tz = -nz * ny;
          const tLenSq = tx * tx + ty * ty + tz * tz;
          if (tLenSq > 1e-12) {
            const invLen = 1.0 / Math.sqrt(tLenSq);
            const ptx = tx * invLen;
            const pty = ty * invLen;
            const ptz = tz * invLen;

            // Check P_top
            const cx1 = (v1.y * ptz - v1.z * pty) * nx + (v1.z * ptx - v1.x * ptz) * ny + (v1.x * pty - v1.y * ptx) * nz;
            const cx2 = (pty * v2.z - ptz * v2.y) * nx + (ptz * v2.x - ptx * v2.z) * ny + (ptx * v2.y - pty * v2.x) * nz;

            // Update minPhi
            if (cx1 > 0 && cx2 > 0) {
              const phiTop = Math.acos(Math.max(-1, Math.min(1, pty)));
              if (phiTop < minPhi) minPhi = phiTop;
            }

            // If P_bot (-P_top) is inside, update maxPhi (Southmost)
            // Symmetry: (v1 x -P) . N = -cx1. So we check if -cx1 > 0 AND -cx2 > 0.
            if (cx1 < 0 && cx2 < 0) {
              const phiBot = Math.acos(Math.max(-1, Math.min(1, -pty)));
              if (phiBot > maxPhi) maxPhi = phiBot;
            }
          }
        }

        // Collect Thetas
        let theta = Math.atan2(v1.x, v1.z);
        if (theta < 0) theta += 2 * Math.PI;
        thetas.push(theta);
      }

      // Pole Logic
      // CCW Winding: Edge Normals point "Right" (Southish for North Face).
      // NP Inside -> Face is North of Edge -> Normal points South (y < 0).
      // So if any Normal points North (y > 0), NP is NOT inside.
      let npInside = true;
      let spInside = true;
      for (const plane of this.planes) {
        if (plane.y < 0) npInside = false;
        if (plane.y > 0) spInside = false;
      }
      if (npInside) minPhi = 0;
      if (spInside) maxPhi = Math.PI;

      // Conservative Bounds
      const margin = thickness + 0.05;
      this.yMin = Math.floor((Math.max(0, minPhi - margin) / Math.PI) * (Daydream.H - 1));
      this.yMax = Math.ceil((Math.min(Math.PI, maxPhi + margin) / Math.PI) * (Daydream.H - 1));

      // Horizontal bounds
      thetas.sort((a, b) => a - b);
      let maxGap = 0;
      let gapStart = 0;
      for (let i = 0; i < thetas.length; i++) {
        const next = (i + 1) < thetas.length ? thetas[i + 1] : (thetas[0] + 2 * Math.PI);
        if (next - thetas[i] > maxGap) { maxGap = next - thetas[i]; gapStart = thetas[i]; }
      }
      if (maxGap > Math.PI) {
        const startPx = Math.floor(((gapStart + maxGap) % (2 * Math.PI) / (2 * Math.PI)) * Daydream.W);
        const endPx = Math.ceil((gapStart / (2 * Math.PI)) * Daydream.W);
        if (startPx <= endPx) this.intervals = [{ start: startPx, end: Math.min(endPx, Daydream.W - 1) }];
        else this.intervals = [{ start: startPx, end: Daydream.W - 1 }, { start: 0, end: Math.min(endPx, Daydream.W - 1) }];
      } else {
        this.intervals = null; // Full width fallback
      }
    }

    getVerticalBounds() { return { yMin: this.yMin, yMax: this.yMax }; }
    getHorizontalBounds(y) { return this.intervals; }

    /**
     * Signed Distance to arbitrary polygon.
     * @param {THREE.Vector3} p - Point.
     * @param {{dist: number, t: number, rawDist: number}} [out] - Result.
     * @returns {{dist: number, t: number, rawDist: number}} Result.
     */
    distance(p, out = { dist: 100, t: 0, rawDist: 100 }) {
      // Hemisphere check
      const cosAngle = p.dot(this.center);
      if (cosAngle <= 0.01) {
        out.dist = 100; return out;
      }

      // Project P
      const px = p.dot(this.basisU) / cosAngle;
      const py = p.dot(this.basisW) / cosAngle;

      // 2D SDF & Winding
      const v = this.poly2D;
      const N = v.length;

      let d = Infinity; // Start with clear max
      let winding = 0;

      for (let i = 0, j = N - 1; i < N; j = i, i++) {
        const Vi = v[i];
        const Vj = v[j];

        const ex = Vj.x - Vi.x;
        const ey = Vj.y - Vi.y;
        const wx = px - Vi.x;
        const wy = py - Vi.y;

        // Edge distance
        const dotWE = wx * ex + wy * ey;
        const dotEE = ex * ex + ey * ey;

        let clampVal = 0;
        if (dotEE > 1e-12) {
          clampVal = Math.max(0, Math.min(1, dotWE / dotEE));
        }

        const bx = wx - ex * clampVal;
        const by = wy - ey * clampVal;
        const distSq = bx * bx + by * by;

        if (distSq < d) d = distSq;

        // Winding
        const isUpward = (Vi.y <= py) && (Vj.y > py);
        const isDownward = (Vi.y > py) && (Vj.y <= py);

        if (isUpward || isDownward) {
          // Calculate intersection X-offset relative to P using cross product
          // Cross(Vj-Vi, P-Vi). If edge goes up, Positive Cross means P is to Right (Ray intersects)
          // Wait, Standard 2D cross: (B.x-A.x)*(P.y-A.y) - (B.y-A.y)*(P.x-A.x)
          // = ex * wy - ey * wx
          const cross = ex * wy - ey * wx;

          if (isUpward) {
            // Edge goes Up. Point Left of edge => Ray Intersects.
            // Left means Cross > 0 (assuming Y-up CCW)
            if (cross > 0) winding++;
          } else {
            // Edge goes Down. Point Left of edge => Ray Intersects.
            if (cross < 0) winding--;
          }
        }
      }

      // Result is distance in Tangent Plane units.
      // Non-Zero Rule: Inside if winding != 0
      const s = (winding !== 0) ? -1.0 : 1.0;

      const planeDist = s * Math.sqrt(d);

      out.dist = planeDist - this.thickness;
      out.t = 0;
      out.rawDist = planeDist;
      return out;
    }
  }
};

export const Scan = {
  /**
   * Rasterizes a shape using scanline conversion.
   * @param {Object} pipeline - Pipeline.
   * @param {Object} shape - SDF shape.
   * @param {Function} colorFn - Color function.
   * @param {boolean} [debugBB=false] - Debug.
   */
  rasterize: (pipeline, shape, colorFn, debugBB = false) => {
    const { yMin, yMax } = shape.getVerticalBounds();

    // Reusable result object to avoid GC
    const sampleResult = { dist: 100, t: 0, rawDist: 100 };

    for (let y = yMin; y <= yMax; y++) {
      let intervals = null;
      if (shape.getHorizontalBounds) {
        intervals = shape.getHorizontalBounds(y);
      }

      if (intervals) {
        // Intervals (Optimized Scan)
        for (let k = 0; k < intervals.length; k++) {
          const iv = intervals[k];
          for (let x = iv.start; x <= iv.end; x++) {
            Scan.processPixel(x, y, pipeline, shape, colorFn, debugBB, sampleResult);
          }
        }
      } else {
        // Full Scan (Fallback)
        for (let x = 0; x < Daydream.W; x++) {
          Scan.processPixel(x, y, pipeline, shape, colorFn, debugBB, sampleResult);
        }
      }
    }
  },

  /**
   * Processes a single pixel.
   * @param {number} x - X coord.
   * @param {number} y - Y coord.
   * @param {Object} pipeline - Pipeline.
   * @param {Object} shape - Shape.
   * @param {Function} colorFn - Color function.
   * @param {boolean} debugBB - Debug.
   * @param {Object} sampleResult - Reusable result.
   */
  processPixel: (x, y, pipeline, shape, colorFn, debugBB, sampleResult) => {
    const wx = wrap(x, Daydream.W);
    const i = wx + y * Daydream.W;
    const p = Daydream.pixelPositions[i];

    if (debugBB) {
      Daydream.pixels[i * 3] += 0.02;
      Daydream.pixels[i * 3 + 1] += 0.02;
      Daydream.pixels[i * 3 + 2] += 0.02;
    }

    shape.distance(p, sampleResult);
    const d = sampleResult.dist;
    if (d < Daydream.PIXEL_WIDTH) {
      const t = 0.5 - d / (2 * Daydream.PIXEL_WIDTH);
      const aaAlpha = quinticKernel(Math.max(0, Math.min(1, t)));

      const c = colorFn(p, sampleResult.t, sampleResult.dist);
      const color = c.isColor ? c : (c.color || c);
      const baseAlpha = (c.alpha !== undefined ? c.alpha : 1.0);

      pipeline.plot2D(wx, y, color, 0, baseAlpha * aaAlpha);
    }
  },

  DistortedRing: class {
    /**
     * Scans a distorted thick ring.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientation - Ring orientation quaternion.
     * @param {THREE.Vector3} normal - Local ring axis.
     * @param {number} radius - Base angular radius.
     * @param {number} thickness - Angular thickness.
     * @param {Function} shiftFn - (t: 0..1) => shift in radians.
     * @param {number} maxDistortion - Max abs(shift) for bucket optimization.
     * @param {Function} materialFn - (pos, t, dist) => {color, alpha}.
     */
    static draw(pipeline, basis, radius, thickness, shiftFn, maxDistortion, colorFn, phase = 0, debugBB = false) {
      const shape = new SDF.DistortedRing(basis, radius, thickness, shiftFn, maxDistortion, phase);
      Scan.rasterize(pipeline, shape, colorFn, debugBB);
    }
  },


  Polygon: class {
    /**
     * @param {Object} pipeline - Pipeline.
     * @param {Object} basis - Basis.
     * @param {number} radius - Radius.
     * @param {number} sides - Sides.
     * @param {Function} colorFn - Color function.
     * @param {number} [phase=0] - Phase.
     * @param {boolean} [debugBB=false] - Debug.
     */
    static draw(pipeline, basis, radius, sides, colorFn, phase = 0, debugBB = false) {
      let { v, u, w } = basis;
      if (radius > 1.0) {
        v = vectorPool.acquire().copy(v).negate();
        u = vectorPool.acquire().copy(u).negate();
        radius = 2.0 - radius;
      }

      const thickness = radius * (Math.PI / 2);
      const shape = new SDF.Polygon({ v, u, w }, radius, thickness, sides, phase);
      const renderColorFn = (p, t, d) => colorFn(p, 0, d);
      Scan.rasterize(pipeline, shape, renderColorFn, debugBB);
    }
  },

  Star: class {
    /**
     * @param {Object} pipeline - Pipeline.
     * @param {Object} basis - Basis.
     * @param {number} radius - Radius.
     * @param {number} sides - Sides.
     * @param {Function} colorFn - Color function.
     * @param {number} [phase=0] - Phase.
     * @param {boolean} [debugBB=false] - Debug.
     */
    static draw(pipeline, basis, radius, sides, colorFn, phase = 0, debugBB = false) {
      let { v, u, w } = basis;
      if (radius > 1.0) {
        v = vectorPool.acquire().copy(v).negate();
        u = vectorPool.acquire().copy(u).negate();
        radius = 2.0 - radius;
      }
      const shape = new SDF.Star({ v, u, w }, radius, sides, phase);
      const renderColorFn = (p, t, d) => colorFn(p, 0, d);
      Scan.rasterize(pipeline, shape, renderColorFn, debugBB);
    }
  },

  Flower: class {
    /**
     * @param {Object} pipeline - Pipeline.
     * @param {Object} basis - Basis.
     * @param {number} radius - Radius.
     * @param {number} sides - Sides.
     * @param {Function} colorFn - Color function.
     * @param {number} [phase=0] - Phase.
     * @param {boolean} [debugBB=false] - Debug.
     */
    static draw(pipeline, basis, radius, sides, colorFn, phase = 0, debugBB = false) {
      let { v, u, w } = basis;
      if (radius > 1.0) {
        v = vectorPool.acquire().copy(v).negate();
        u = vectorPool.acquire().copy(u).negate();
        radius = 2.0 - radius;
      }
      const shape = new SDF.Flower({ v, u, w }, radius, sides, phase);
      const renderColorFn = (p, t, d) => colorFn(p, 0, d);
      Scan.rasterize(pipeline, shape, renderColorFn, debugBB);
    }
  },

  Circle: class {
    /**
     * Scans a solid circle (disk) on the sphere.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Vector3} normal - Center of the circle.
     * @param {number} radius - Angular radius (0-2).
     * @param {Function} colorFn - (pos, t, dist) => {color, alpha}.
     * @param {Object} options - Options.
     */
    static draw(pipeline, basis, radius, colorFn, phase = 0, debugBB = false) {
      // A circle is a ring with radius 0 and thickness = radius
      const thickness = radius * (Math.PI / 2);
      Scan.Ring.draw(pipeline, basis, 0, thickness, colorFn, phase, debugBB);
    }
  },

  Ring: class {
    /**
     * Scans a thick ring and feeds pixels into the pipeline.
     * @param {Object} pipeline - The render pipeline (must support plot2D).
     * @param {THREE.Quaternion} orientationQuaternion - Ring orientation.
     * @param {THREE.Vector3} normal - Ring orientation.
     * @param {number} radius - Angular radius (0-2).
     * @param {number} thickness - Angular thickness.
     * @param {Function} colorFn - (pos, t, dist) => {color, alpha}.
     * @param {number} [phase=0] - Phase of the ring.
     * @param {boolean} [debugBB=false] - Whether to show bounding boxes.
     */
    static draw(pipeline, basis, radius, thickness, colorFn, phase = 0, debugBB = false) {
      const shape = new SDF.Ring(basis, radius, thickness, phase);
      Scan.rasterize(pipeline, shape, colorFn, debugBB);
    }
  },

  Line: class {
    /**
     * Scans a line between two points. (Simplified Scan).
     * @param {Object} pipeline - Render pipeline.
     * @param {Object} pixels - Pixel buffer (unused in signature but implied environment).
     * @param {THREE.Vector3} v1 - Start point.
     * @param {THREE.Vector3} v2 - End point.
     * @param {number} thickness - Line thickness.
     * @param {Function} colorFn - Color function.
     * @param {Object} options - Options.
     */
    static draw(pipeline, pixels, v1, v2, thickness, colorFn, options = {}) {
      const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
      if (normal.lengthSq() < 0.000001) return;

      const c1 = new THREE.Vector3().crossVectors(normal, v1);
      const c2 = new THREE.Vector3().crossVectors(v2, normal);

      let maxY = Math.max(v1.y, v2.y);
      let minY = Math.min(v1.y, v2.y);
      const apexPlaneNormal = new THREE.Vector3().crossVectors(normal, new THREE.Vector3(0, 1, 0));
      if (apexPlaneNormal.lengthSq() > 0.0001) {
        const d1 = v1.dot(apexPlaneNormal);
        const d2 = v2.dot(apexPlaneNormal);
        if (d1 * d2 <= 0) {
          const globalMaxY = Math.sqrt(1 - normal.y * normal.y);
          if (v1.y + v2.y > 0) maxY = globalMaxY;
          else minY = -globalMaxY;
        }
      }

      const minPhi = Math.acos(Math.min(1, Math.max(-1, maxY))) - thickness;
      const maxPhi = Math.acos(Math.min(1, Math.max(-1, minY))) + thickness;

      Scan.Ring.draw(pipeline, normal, 1.0, thickness, colorFn, 0, 2 * Math.PI, {
        ...options,
        clipPlanes: [c1, c2],
        limits: { minPhi, maxPhi }
      });
    }
  },

  Mesh: class {
    /**
     * Scans a solid mesh face by face.
     * @param {Object} pipeline - Render pipeline.
     * @param {Object} mesh - {vertices: Vector3[], faces: number[][]}.
     * @param {Function} colorFn - Color function.
     * @param {boolean} [debugBB=false] - Debug.
     */
    static draw(pipeline, mesh, colorFn, debugBB = false) {
      for (let i = 0; i < mesh.faces.length; i++) {
        const face = mesh.faces[i];
        const verts = face.map(idx => mesh.vertices[idx]);
        // Zero thickness for solid face
        const shape = new SDF.Face(verts, 0);
        // Pass face index (i) as 4th argument to colorFn
        const renderColorFn = (p, t, d) => colorFn(p, t, d / (shape.size || 1.0), i);
        Scan.rasterize(pipeline, shape, renderColorFn, debugBB);
      }
    }
  },

  Point: class {
    /**
     * @param {Object} pipeline - Pipeline.
     * @param {THREE.Vector3} pos - Position.
     * @param {number} thickness - Thickness.
     * @param {Function} colorFn - Color function.
     * @param {Object} options - Options.
     */
    static draw(pipeline, pos, thickness, colorFn, options) {
      const identity = quaternionPool.acquire().identity();
      const basis = makeBasis(identity, pos);
      // A point is a Ring with radius 0 and some thickness
      Scan.Ring.draw(pipeline, basis, 0, thickness, colorFn, 0, options && options.debugBB);
    }
  },

  Field: class {
    /**
     * @param {Object} pipeline - Pipeline.
     * @param {Function} colorFn - Color function.
     */
    static draw(pipeline, colorFn) {
      for (let i = 0; i < Daydream.pixelPositions.length; i++) {
        const x = i % Daydream.W;
        const y = (i / Daydream.W) | 0;

        const p = Daydream.pixelPositions[i];
        const mat = colorFn(p);

        const color = mat.isColor ? mat : (mat.color || mat);
        const alpha = (mat.alpha !== undefined ? mat.alpha : 1.0);

        if (pipeline.plot) {
          pipeline.plot(p, color, 0, alpha);
        } else if (pipeline.plot2D) {
          pipeline.plot2D(x, y, color, 0, alpha);
        }
      }
    }
  }
};