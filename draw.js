/*
 * Required Notice: Copyright 2025 Gabriel Levy. All rights reserved.
 * Licensed under the Polyform Noncommercial License 1.0.0
 */

import * as THREE from "three";
import { Daydream, labels, XY } from "./driver.js";
import { Dot, angleBetween, fibSpiral, vectorPool, quaternionPool, yToPhi } from "./geometry.js";
import { quinticKernel } from "./filters.js";
import { wrap } from "./util.js";
import { StaticPool } from "./StaticPool.js";

/** @type {StaticPool} Global pool for Dot objects. */
export const dotPool = new StaticPool(Dot, 500000);

// Reusable temporary objects to avoid allocation during render loops
const _tempVec = new THREE.Vector3();


/**
 * Represents a path composed of connected points on the sphere.
 */
export class Path {
  /**
   * @param {THREE.Vector3} initialPos - The starting position of the path.
   */
  constructor(initialPos) {
    this.points = [initialPos.clone()];
  }

  /**
   * Collapses the path to only the last point.
   */
  collapse() {
    this.points = [this.points[this.points.length - 1]];
  }

  /**
   * Gets the number of points in the path.
   * @returns {number} The length of the path.
   */
  length() {
    return this.points.length;
  }

  /**
   * Appends a line segment between two vectors to the path.
   * @param {THREE.Vector3} c1 - The start vector.
   * @param {THREE.Vector3} c2 - The end vector.
   * @param {boolean} [longWay=false] - If true, take the longer arc.
   * @param {Function} [easingFn=(t) => t] - An unused easing function (retained for signature).
   * @returns {Path} The path instance.
   */
  appendLine(c1, c2, longWay = false, easingFn = (t) => t) {
    if (this.points.length > 0) {
      this.points.pop();
    }
    this.points.push(c2.clone());
    return this;
  }

  /**
   * Appends a segment generated by a plotting function.
   * @param {Function} plotFn - Function that returns a vector based on a domain parameter t.
   * @param {number} domain - The range of the input parameter for plotFn.
   * @param {number} samples - The number of points to sample.
   * @param {Function} [easingFn=(t) => t] - The easing function to apply to the input parameter.
   * @returns {Path} The path instance.
   */
  appendSegment(plotFn, domain, samples, easingFn = (t) => t) {
    if (this.points.length > 0) {
      this.points.pop();
    }
    for (let t = 0; t <= samples; t++) {
      // Must clone() because plotFn might return a pooled vector
      this.points.push(plotFn(easingFn(t / samples) * domain).clone());
    }
    return this;
  }

  /**
   * Gets a point on the path based on a normalized parameter t.
   * @param {number} t - Normalized position along the path [0, 1].
   * @returns {THREE.Vector3} A clone of the point at the given position.
   */
  getPoint(t) {
    const rawIndex = t * (this.points.length - 1);
    const i = Math.floor(rawIndex);
    const f = rawIndex - i;

    // Handle end of path
    if (i >= this.points.length - 1) {
      return vectorPool.acquire().copy(this.points[this.points.length - 1]);
    }

    const p1 = this.points[i];
    const p2 = this.points[i + 1];
    return vectorPool.acquire().copy(p1).lerp(p2, f);
  }
}

/**
 * Represents a path defined by a single procedural function.
 */
export class ProceduralPath {
  /**
   * @param {Function} pathFn - Function that takes a parameter t [0, 1] and returns a THREE.Vector3.
   */
  constructor(pathFn) {
    this.f = pathFn;
  }

  /**
   * Gets a point on the path.
   * @param {number} t - Normalized position along the path [0, 1].
   * @returns {THREE.Vector3} The point on the path.
   */
  getPoint(t) {
    return this.f(t);
  }
}

/**
 * Rasterizes a list of points into Dot objects by connecting them with geodesic lines.
 * @param {Object} pipeline - The render pipeline.
 * @param {THREE.Vector3[]} points - The list of points.
 * @param {Function} colorFn - Function to determine color (takes vector and normalized progress t).
 * @param {boolean} [closeLoop=false] - If true, connects the last point to the first.
 */
export const rasterize = (pipeline, points, colorFn, closeLoop = false) => {
  const len = points.length;
  if (len === 0) return;

  const count = closeLoop ? len : len - 1;
  for (let i = 0; i < count; i++) {
    const p1 = points[i];
    const p2 = points[(i + 1) % len];

    const segmentColorFn = (p, subT) => {
      const globalT = (i + subT) / count;
      return colorFn(p, globalT);
    };

    // Draw segment
    const omitLast = closeLoop || (i < count - 1);
    Plot.Line.draw(pipeline, p1, p2, segmentColorFn, 0, 1, false, omitLast);
  }
};

/**
 * Draws a motion trail by tweening between orientations in the queue.
 * @param {Orientation} orientation - The orientation object containing the motion history.
 * @param {Function} drawFn - Function to draw a segment (takes orientation quaternion and normalized progress).
 */
export const tween = (orientation, drawFn) => {
  let s = orientation.length();
  let start = (s > 1) ? 1 : 0;
  for (let i = start; i < s; ++i) {
    drawFn(orientation.get(i), (s - 1 - i) / s);
  }
}

/**
 * Performs a deep tween on an OrientationTrail, handling interpolation between frames.
 * @param {OrientationTrail} trail - The trail of orientation histories.
 * @param {Function} drawFn - Function to draw a sample (takes quaternion and global time t).
 */
export const deepTween = (trail, drawFn) => {
  const dt = 1.0 / trail.capacity;
  tween(trail, (frame, t) => {
    tween(frame, (q, subT) => {
      const globalT = t + subT * dt;
      drawFn(q, globalT);
    });
  });
}

export const Plot = {
  Point: class {
    /**
     * Draws a single dot at a given vector.
     * @param {Object} pipeline - The render pipeline.
     * @param {THREE.Vector3} v - The vector position (normalized).
     * @param {Function} colorFn - Function to determine the color (takes vector and t=0).
     */
    static draw(pipeline, v, colorFn) {
      const c = colorFn(v, 0);
      const color = c.isColor ? c : (c.color || c);
      const alpha = c.alpha !== undefined ? c.alpha : 1.0;
      pipeline.plot(v, color, 0, alpha);
    }
  },

  Path: class {
    /**
     * Draws a sequence of points along a Path object.
     * @param {Object} pipeline - The render pipeline.
     * @param {Path|ProceduralPath} path - The path object.
     * @param {Function} colorFn - Function to determine the color (takes normalized time t).
     */
    static draw(pipeline, path, colorFn) {
      for (let t = 0; t < path.length(); t++) {
        const v = path.getPoint(t / path.length());
        const c = colorFn(t);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(v, color, 0, alpha);
      }
    }
  },

  Line: class {
    /**
     * Draws a geodesic line (arc) between two vectors on the sphere with adaptive sampling.
     * @param {Object} pipeline - The render pipeline.
     * @param {THREE.Vector3} v1 - The start vector.
     * @param {THREE.Vector3} v2 - The end vector.
     * @param {Function} colorFn - Function to determine the color (takes vector and normalized progress t).
     * @param {number} [start=0] - Starting angle multiplier for drawing the line arc.
     * @param {number} [end=1] - Ending multiplier for the total arc angle.
     * @param {boolean} [longWay=false] - If true, draws the longer arc.
     * @param {boolean} [omitLast=false] - If true, omits the last point.
     */
    static draw(pipeline, v1, v2, colorFn, start = 0, end = 1, longWay = false, omitLast = false) {
      let u = vectorPool.acquire().copy(v1);
      let v = vectorPool.acquire().copy(v2);
      let a = angleBetween(u, v);
      let w = vectorPool.acquire();

      if (Math.abs(a) < 0.0001) {
        if (omitLast) return;

        const c = colorFn(u, 0);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(u, color, 0, alpha);
        return;
      } else if (Math.abs(Math.PI - a) < 0.0001) {
        if (Math.abs(v.dot(Daydream.X_AXIS)) > 0.9999) {
          w.crossVectors(u, Daydream.Y_AXIS).normalize();
        } else {
          w.crossVectors(u, Daydream.X_AXIS).normalize();
        }
      } else {
        w.crossVectors(u, v).normalize();
      }

      if (longWay) {
        a = 2 * Math.PI - a;
        w.negate();
      }

      if (start != 0) {
        let q = quaternionPool.acquire().setFromAxisAngle(w, start * a);
        u.applyQuaternion(q).normalize();
      }
      a *= Math.abs(end - start);

      // Simulation Phase
      let simU = vectorPool.acquire().copy(u);
      let simAngle = 0;
      let steps = [];
      const baseStep = 2 * Math.PI / Daydream.W;

      while (simAngle < a) {
        let scaleFactor = Math.max(0.05, Math.sqrt(Math.max(0, 1.0 - simU.y * simU.y)));
        let step = baseStep * scaleFactor;
        steps.push(step);
        simAngle += step;

        // Advance simU
        let q = quaternionPool.acquire().setFromAxisAngle(w, step);
        simU.applyQuaternion(q).normalize();
      }

      // Calculate Scale Factor
      let scale = a / simAngle;

      // Drawing Phase


      let currentAngle = 0;

      const startC = colorFn(u, 0);
      const startColor = startC.isColor ? startC : (startC.color || startC);
      const startAlpha = startC.alpha !== undefined ? startC.alpha : 1.0;
      pipeline.plot(u, startColor, 0, startAlpha);

      let loopLimit = omitLast ? steps.length - 1 : steps.length;
      for (let i = 0; i < loopLimit; i++) {
        let step = steps[i] * scale;

        // Advance u
        let q = quaternionPool.acquire().setFromAxisAngle(w, step);
        u.applyQuaternion(q).normalize();
        currentAngle += step;

        // Normalized t
        let t = (a > 0) ? (currentAngle / a) : 1;

        const c = colorFn(u, t);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(u, color, 0, alpha);
      }
    }
  },

  Vertices: class {
    /**
     * Draws a set of vertices as individual dots.
     * @param {Object} pipeline - The render pipeline.
     * @param {number[][]} vertices - An array of [x, y, z] arrays.
     * @param {Function} colorFn - Function to determine the color (takes vector).
     */
    static draw(pipeline, vertices, colorFn) {
      let v = vectorPool.acquire();
      for (const vertex of vertices) {
        v.set(vertex[0], vertex[1], vertex[2]);
        const c = colorFn(v);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(v, color, 0, alpha);
      }
    }
  },

  Polyhedron: class {
    /**
     * Samples points for the edges of a polyhedron.
     * @param {number[][]} vertices - An array of [x, y, z] vertex arrays.
     * @param {number[][]} edges - An adjacency list of vertex indices.
     * @returns {THREE.Vector3[]} An array of points forming the edges.
     */
    static sample(vertices, edges) {
      let points = [];
      edges.map((adj, i) => {
        adj.map((j) => {
          // Just push the vertices, let rasterize handle the lines
          points.push(vectorPool.acquire().set(...vertices[i]).normalize());
          points.push(vectorPool.acquire().set(...vertices[j]).normalize());
        })
      });
      return points;
    }

    /**
     * Draws the edges of a polyhedron by drawing lines between connected vertices.
     * @param {Object} pipeline - The render pipeline.
     * @param {number[][]} vertices - An array of [x, y, z] vertex arrays.
     * @param {number[][]} edges - An adjacency list of vertex indices.
     * @param {Function} colorFn - Function to determine the color (takes vector and normalized progress t).
     */
    static draw(pipeline, vertices, edges, colorFn) {
      edges.map((adj, i) => {
        adj.map((j) => {
          if (i < j) {
            Plot.Line.draw(
              pipeline,
              vectorPool.acquire().set(...vertices[i]).normalize(),
              vectorPool.acquire().set(...vertices[j]).normalize(),
              colorFn);
          }
        })
      });
    }
  },

  Ring: class {
    /**
     * Calculates a point on a circle that lies on the surface of the unit sphere.
     * @param {number} a - Angle.
     * @param {number} radius - Radius.
     * @param {THREE.Vector3} u - Basis U.
     * @param {THREE.Vector3} v - Basis V (Normal).
     * @param {THREE.Vector3} w - Basis W.
     * @returns {THREE.Vector3} Point.
     */
    static calcPoint(a, radius, u, v, w) {
      let d = Math.sqrt(Math.pow(1 - radius, 2));
      return vectorPool.acquire().set(
        d * v.x + radius * u.x * Math.cos(a) + radius * w.x * Math.sin(a),
        d * v.y + radius * u.y * Math.cos(a) + radius * w.y * Math.sin(a),
        d * v.z + radius * u.z * Math.cos(a) + radius * w.z * Math.sin(a)
      ).normalize();
    }

    /**
     * Samples points for a polygon or ring on the sphere surface.
     * @param {THREE.Quaternion} orientationQuaternion - The orientation of the ring.
     * @param {THREE.Vector3} normal - The normal vector defining the ring plane.
     * @param {number} radius - The radius of the ring.
     * @param {number} numSamples - The number of points to sample.
     * @param {number} [phase=0] - Starting phase.
     * @returns {THREE.Vector3[]} An array of points.
     */
    static sample(orientationQuaternion, normal, radius, numSamples, phase = 0) {
      // Basis
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(normal.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }
      let v = vectorPool.acquire().copy(normal).applyQuaternion(orientationQuaternion).normalize();
      let ref = vectorPool.acquire().copy(refAxis).applyQuaternion(orientationQuaternion).normalize();
      let u = vectorPool.acquire().crossVectors(v, ref).normalize();
      let w = vectorPool.acquire().crossVectors(v, u).normalize();

      // Backside rings
      let vDir = v.clone();
      if (radius > 1) {
        vDir.negate();
        radius = 2 - radius;
      }

      const thetaEq = radius * (Math.PI / 2);
      const r = Math.sin(thetaEq);
      const d = Math.cos(thetaEq);

      // Calculate Samples
      const step = 2 * Math.PI / numSamples;
      let points = [];
      let uTemp = vectorPool.acquire();

      for (let i = 0; i < numSamples; i++) {
        let theta = i * step;
        let t = theta + phase;
        let cosRing = Math.cos(t);
        let sinRing = Math.sin(t);
        uTemp.copy(u).multiplyScalar(cosRing).addScaledVector(w, sinRing);
        let p = vectorPool.acquire().copy(vDir).multiplyScalar(d).addScaledVector(uTemp, r).normalize();
        points.push(p);
      }
      return points;
    }

    /**
     * Draws a circular ring on the sphere surface with adaptive sampling.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientationQuaternion - The orientation of the ring.
     * @param {THREE.Vector3} normal - The normal vector defining the ring plane.
     * @param {number} radius - The radius of the ring.
     * @param {Function} colorFn - Function to determine color.
     * @param {number} [phase=0] - Starting phase.
     */
    static draw(pipeline, orientationQuaternion, normal, radius, colorFn, phase = 0) {
      const points = Plot.Ring.sample(orientationQuaternion, normal, radius, Daydream.W / 4, phase);
      rasterize(pipeline, points, colorFn, true);
    }
  },

  PlanarLine: class {
    /**
     * Draws a line that is straight in the Azimuthal Equidistant projection centered at 'center'.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Vector3} v1 - Start point (normalized).
     * @param {THREE.Vector3} v2 - End point (normalized).
     * @param {THREE.Vector3} center - Center of projection (normalized).
     * @param {Function} colorFn - (t) => {color, alpha}.
     */
    static draw(pipeline, v1, v2, center, colorFn) {
      // Basis for projection
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(center.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }
      const v = center.clone(); // The 'pole'
      const ref = Math.abs(v.dot(Daydream.X_AXIS)) > 0.9 ? Daydream.Y_AXIS : Daydream.X_AXIS;
      const u = vectorPool.acquire().crossVectors(v, ref).normalize();
      const w = vectorPool.acquire().crossVectors(v, u).normalize();

      const project = (p) => {
        const R = angleBetween(p, v);
        if (R < 0.0001) return new THREE.Vector2(0, 0);
        const x = p.dot(u);
        const y = p.dot(w);
        const theta = Math.atan2(y, x);
        return new THREE.Vector2(R * Math.cos(theta), R * Math.sin(theta));
      };

      const p1 = project(v1);
      const p2 = project(v2);

      const dist = p1.distanceTo(p2);
      const numSteps = Math.max(2, Math.ceil(dist * Daydream.W / (2 * Math.PI)));

      let pTemp = vectorPool.acquire();

      for (let i = 0; i < numSteps; i++) {
        const t = i / (numSteps - 1);
        const Px = p1.x + (p2.x - p1.x) * t;
        const Py = p1.y + (p2.y - p1.y) * t;

        const R = Math.sqrt(Px * Px + Py * Py);
        const theta = Math.atan2(Py, Px);

        let point = vectorPool.acquire().copy(v);
        if (R > 0.0001) {
          const sinR = Math.sin(R);
          const cosR = Math.cos(R);
          const cosT = Math.cos(theta);
          const sinT = Math.sin(theta);

          // dir = u*cosT + w*sinT
          const dir = vectorPool.acquire().copy(u).multiplyScalar(cosT).addScaledVector(w, sinT).normalize();
          // p = v*cosR + dir*sinR
          point.multiplyScalar(cosR).addScaledVector(dir, sinR).normalize();
        }

        const c = colorFn(t);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(point, color, 0, alpha);
      }
    }
  },

  Polygon: class {
    /**
     * Draws a polygon on the sphere surface.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientationQuaternion - The orientation of the polygon.
     * @param {THREE.Vector3} normal - The normal vector.
     * @param {number} radius - The radius.
     * @param {number} numSides - Number of sides.
     * @param {Function} colorFn - Function to determine color.
     * @param {number} [phase=0] - Starting phase.
     */
    static draw(pipeline, orientationQuaternion, normal, radius, numSides, colorFn, phase = 0) {
      const points = Plot.Polygon.sample(orientationQuaternion, normal, radius, numSides, phase);
      let center = normal.clone().applyQuaternion(orientationQuaternion).normalize();

      // Fix: If radius > 1, the points are on the backside.
      // To draw a regular convex polygon, we must project relative to the antipode.
      if (radius > 1.0) {
        center.negate();
      }

      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        Plot.PlanarLine.draw(pipeline, p1, p2, center, (t) => colorFn(p1, t));
      }
    }

    static sample(orientationQuaternion, normal, radius, numSides, phase = 0) {
      // Offset by half-sector to align with Scan.Polygon edges
      const offset = Math.PI / numSides;
      return Plot.Ring.sample(orientationQuaternion, normal, radius, numSides, phase + offset);
    }
  },

  Star: class {
    static draw(pipeline, orientationQuaternion, normal, radius, numSides, colorFn, phase = 0) {
      if (radius > 1.0) {
        normal = normal.clone().negate();
        radius = 2.0 - radius;
      }

      const outerRadius = radius * (Math.PI / 2);
      const innerRadius = outerRadius * 0.382;

      const points = [];
      const angleStep = Math.PI / numSides;

      // Basis construction
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(normal.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }
      const v = normal.clone().applyQuaternion(orientationQuaternion).normalize();
      const ref = refAxis.clone().applyQuaternion(orientationQuaternion).normalize();
      const u = vectorPool.acquire().crossVectors(v, ref).normalize();
      const w = vectorPool.acquire().crossVectors(v, u).normalize();

      for (let i = 0; i < numSides * 2; i++) {
        const theta = phase + i * angleStep;
        const r = (i % 2 === 0) ? outerRadius : innerRadius;

        const sinR = Math.sin(r);
        const cosR = Math.cos(r);
        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);

        const p = vectorPool.acquire()
          .copy(v).multiplyScalar(cosR)
          .addScaledVector(u, cosT * sinR)
          .addScaledVector(w, sinT * sinR)
          .normalize();

        points.push(p);
      }

      // Projection center (Front)
      const center = v;

      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        Plot.PlanarLine.draw(pipeline, p1, p2, center, (t) => colorFn(p1, t));
      }
    }
  },

  Flower: class {
    static draw(pipeline, orientationQuaternion, normal, radius, numSides, colorFn, phase = 0) {
      if (radius > 1.0) {
        normal = normal.clone().negate();
        radius = 2.0 - radius;
      }

      // Original logic: Projection Distortion of Antipodal Polygon
      const desiredOuterRadius = radius * (Math.PI / 2);
      const apothem = Math.PI - desiredOuterRadius;
      const angle = Math.PI / numSides;
      const polyRadiusRadians = apothem / Math.cos(angle);

      const polyRadiusNorm = polyRadiusRadians / (Math.PI / 2);

      const antiNormal = normal.clone().negate();
      const points = Plot.Polygon.sample(orientationQuaternion, antiNormal, polyRadiusNorm, numSides, phase);

      // Center for projection: The Antipode (which makes the straight lines of the polygon curved at the front)
      let center = antiNormal.clone().applyQuaternion(orientationQuaternion).normalize();

      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        Plot.PlanarLine.draw(pipeline, p1, p2, center, (t) => colorFn(p1, t));
      }
    }
  },

  DistortedRing: class {


    /**
     * Calculates a single point on a sphere distorted by a function.
     * @param {Function} f - The shift function.
     * @param {THREE.Vector3} normal - The normal.
     * @param {number} radius - The base radius.
     * @param {number} angle - The angle.
     */
    static point(f, normal, radius, angle) {
      let u = vectorPool.acquire();
      let v = vectorPool.acquire().copy(normal);
      let w = vectorPool.acquire();
      if (radius > 1) {
        v.negate();
        radius = 2 - radius;
      }
      if (Math.abs(v.dot(Daydream.X_AXIS)) > 0.99995) {
        u.crossVectors(v, Daydream.Y_AXIS).normalize();
      } else {
        u.crossVectors(v, Daydream.X_AXIS).normalize();
      }
      w.crossVectors(v, u);

      let vi = Plot.Ring.calcPoint(angle, radius, u, v, w);
      let vp = Plot.Ring.calcPoint(angle, 1, u, v, w);
      let axis = vectorPool.acquire().crossVectors(v, vp).normalize();
      let shift = new THREE.Quaternion().setFromAxisAngle(axis, f(angle * Math.PI / 2));
      return vi.applyQuaternion(shift);
    }

    /**
     * Samples points for a function-distorted ring.
     * @param {THREE.Quaternion} orientationQuaternion - Orientation.
     * @param {THREE.Vector3} normal - Normal.
     * @param {number} radius - Radius.
     * @param {Function} shiftFn - Shift function.
     * @param {number} [phase=0] - Phase.
     */
    static sample(orientationQuaternion, normal, radius, shiftFn, phase = 0) {
      // Basis
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(normal.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }
      let v = vectorPool.acquire().copy(normal).applyQuaternion(orientationQuaternion).normalize();
      let ref = vectorPool.acquire().copy(refAxis).applyQuaternion(orientationQuaternion).normalize();
      let u = vectorPool.acquire().crossVectors(v, ref).normalize();
      let w = vectorPool.acquire().crossVectors(v, u).normalize();

      // Backside rings
      let vSign = 1.0;
      if (radius > 1) {
        vSign = -1.0;
        radius = 2 - radius;
      }

      // Equidistant projection
      const thetaEq = radius * (Math.PI / 2);
      const r = Math.sin(thetaEq);
      const d = Math.cos(thetaEq);

      // Calculate Samples
      const numSamples = Daydream.W;
      const step = 2 * Math.PI / numSamples;
      let points = [];
      let uTemp = vectorPool.acquire();

      for (let i = 0; i < numSamples; i++) {
        let theta = i * step;
        let t = theta + phase;
        let cosRing = Math.cos(t);
        let sinRing = Math.sin(t);
        uTemp.copy(u).multiplyScalar(cosRing).addScaledVector(w, sinRing);

        // Apply Shift
        let shift = shiftFn(theta / (2 * Math.PI));
        let cosShift = Math.cos(shift);
        let sinShift = Math.sin(shift);
        let vScale = (vSign * d) * cosShift - r * sinShift;
        let uScale = r * cosShift + (vSign * d) * sinShift;
        let p = vectorPool.acquire().copy(v).multiplyScalar(vScale).addScaledVector(uTemp, uScale).normalize();

        points.push(p);
      }

      return points;
    }

    /**
     * Draws a function-distorted ring.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientationQuaternion - Orientation.
     * @param {THREE.Vector3} normal - Normal.
     * @param {number} radius - Radius.
     * @param {Function} shiftFn - Shift function.
     * @param {Function} colorFn - Color function.
     * @param {number} [phase=0] - Phase.
     */
    static draw(pipeline, orientationQuaternion, normal, radius, shiftFn, colorFn, phase = 0) {
      const points = Plot.DistortedRing.sample(orientationQuaternion, normal, radius, shiftFn, phase);
      rasterize(pipeline, points, colorFn, true);
    }
  },

  Spiral: class {
    /**
     * Draws points forming a Fibonacci spiral pattern.
     * @param {Object} pipeline - Render pipeline.
     * @param {number} n - Total number of points.
     * @param {number} eps - Epsilon value for spiral offset.
     * @param {Function} colorFn - Function to determine the color (takes vector).
     */
    static draw(pipeline, n, eps, colorFn) {
      for (let i = 0; i < n; ++i) {
        let v = fibSpiral(n, eps, i);
        const c = colorFn(v);
        const color = c.isColor ? c : (c.color || c);
        const alpha = c.alpha !== undefined ? c.alpha : 1.0;
        pipeline.plot(v, color, 0, alpha);
      }
    }
  }

};

export const Scan = {
  DistortedRing: class {
    /**
     * Scans a distorted thick ring.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientation - Ring orientation quaternion.
     * @param {THREE.Vector3} normal - Local ring axis.
     * @param {number} radius - Base angular radius.
     * @param {number} thickness - Angular thickness.
     * @param {Function} shiftFn - (t: 0..1) => shift in radians.
     * @param {number} amplitude - Max abs(shift) for bucket optimization.
     * @param {Function} materialFn - (pos, t, dist) => {color, alpha}.
     */
    static draw(pipeline, orientation, normal, radius, thickness, shiftFn, amplitude, colorFn, options = {}) {
      // Conservative bounds
      const maxThickness = thickness + amplitude;

      // Basis Construction matching Plot.Ring => Stable Twist
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(normal.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }

      // Calculate Basis
      const v = vectorPool.acquire().copy(normal).applyQuaternion(orientation).normalize();
      const ref = vectorPool.acquire().copy(refAxis).applyQuaternion(orientation).normalize();
      const u = vectorPool.acquire().crossVectors(v, ref).normalize();
      const w = vectorPool.acquire().crossVectors(v, u).normalize();

      const nx = v.x;
      const ny = v.y;
      const nz = v.z;

      const targetAngle = radius * (Math.PI / 2);
      const R = Math.sqrt(nx * nx + nz * nz);
      const alpha = Math.atan2(nx, nz);
      const centerPhi = Math.acos(ny);

      const ctx = {
        normal: v, radius, thickness, shiftFn, colorFn,
        nx, ny, nz, targetAngle, R, alpha, centerPhi,
        u, w,
        pipeline,
        debugBB: options.debugBB,
        maxThickness // For bounding
      };

      // Exact implementation of Ring's vertical bounds check but with maxThickness
      const a1 = centerPhi - targetAngle;
      const a2 = centerPhi + targetAngle;
      const p1 = Math.acos(Math.cos(a1));
      const p2 = Math.acos(Math.cos(a2));
      const minP = Math.min(p1, p2);
      const maxP = Math.max(p1, p2);

      const phiMin = Math.max(0, minP - maxThickness);
      const phiMax = Math.min(Math.PI, maxP + maxThickness);

      if (phiMin > phiMax) return;

      const yMin = Math.max(0, Math.floor((phiMin * (Daydream.H - 1)) / Math.PI));
      const yMax = Math.min(Daydream.H - 1, Math.ceil((phiMax * (Daydream.H - 1)) / Math.PI));

      for (let y = yMin; y <= yMax; y++) {
        Scan.DistortedRing.scanRow(y, ctx);
      }
    }

    static scanRow(y, ctx) {
      const phi = yToPhi(y);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);

      const ang_low = Math.max(0, ctx.targetAngle - ctx.maxThickness);
      const ang_high = Math.min(Math.PI, ctx.targetAngle + ctx.maxThickness);
      const D_max = Math.cos(ang_low);
      const D_min = Math.cos(ang_high);

      // Standard Ring Scan Math using maxThickness
      if (ctx.R < 0.01) {
        // Near pole, just scan full row if in vertical bounds (checked by y loop)
        Scan.DistortedRing.scanFullRow(y, ctx);
        return;
      }

      const denom = ctx.R * sinPhi;
      if (Math.abs(denom) < 0.000001) {
        Scan.DistortedRing.scanFullRow(y, ctx);
        return;
      }

      const C_min = (D_min - ctx.ny * cosPhi) / denom;
      const C_max = (D_max - ctx.ny * cosPhi) / denom;
      // Intersection interval for cos(diffAlpha)
      const minCos = Math.max(-1, C_min);
      const maxCos = Math.min(1, C_max);

      if (minCos > maxCos) return;

      const angleMin = Math.acos(maxCos);
      const angleMax = Math.acos(minCos);

      // Pixel-aware threshold to prevent double-scanning due to floor/ceil overlap
      // Width of one pixel in radians = 2 * PI / W
      const pixelWidth = 2 * Math.PI / Daydream.W;
      const safeThreshold = pixelWidth;

      // Scan the conservative windows
      if (angleMin <= safeThreshold) {
        Scan.DistortedRing.scanWindow(y, ctx.alpha - angleMax, ctx.alpha + angleMax, ctx);
      } else if (angleMax >= Math.PI - safeThreshold) {
        Scan.DistortedRing.scanWindow(y, ctx.alpha + angleMin, ctx.alpha + 2 * Math.PI - angleMin, ctx);
      } else {
        Scan.DistortedRing.scanWindow(y, ctx.alpha - angleMax, ctx.alpha - angleMin, ctx);
        Scan.DistortedRing.scanWindow(y, ctx.alpha + angleMin, ctx.alpha + angleMax, ctx);
      }
    }

    static scanFullRow(y, ctx) {
      for (let x = 0; x < Daydream.W; x++) {
        Scan.DistortedRing.processPixel(XY(x, y), x, y, ctx);
      }
    }

    static scanWindow(y, t1, t2, ctx) {
      const x1 = Math.floor((t1 * Daydream.W) / (2 * Math.PI));
      const x2 = Math.ceil((t2 * Daydream.W) / (2 * Math.PI));

      // Prevent double scanning if window >= 2pi
      if (x2 - x1 >= Daydream.W) {
        Scan.DistortedRing.scanFullRow(y, ctx);
        return;
      }

      for (let x = x1; x <= x2; x++) {
        const wx = wrap(x, Daydream.W);
        Scan.DistortedRing.processPixel(XY(wx, y), wx, y, ctx);
      }
    }

    static processPixel(i, x, y, ctx) {
      const p = Daydream.pixelPositions[i];

      if (ctx.debugBB) {
        Daydream.pixels[i].b += 0.2;
      }

      // Calc Polar Angle
      const polarAngle = angleBetween(p, ctx.normal);

      // Calc Azimuth for Modulation
      const dotU = p.dot(ctx.u);
      const dotW = p.dot(ctx.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;

      // Distorted Target
      const normAzimuth = azimuth / (2 * Math.PI);
      const shift = ctx.shiftFn(normAzimuth);
      const localTarget = ctx.targetAngle + shift;

      // Check Dist
      const dist = Math.abs(polarAngle - localTarget);

      if (dist < ctx.thickness) {
        const distT = dist / ctx.thickness;
        const aaAlpha = quinticKernel(1.0 - distT);

        // Pass t as normalized azimuth to colorFn, matching Plot.Ring behavior
        const c = ctx.colorFn(p, normAzimuth, dist);
        const color = c.isColor ? c : (c.color || c);
        const baseAlpha = (c.alpha !== undefined ? c.alpha : 1.0);

        ctx.pipeline.plot2D(x, y, color, 0, baseAlpha * aaAlpha);
      }
    }
  },

  Polygon: class {
    /**
     * Scans a regular polygon with soft edges.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Quaternion} orientation - Orientation.
     * @param {THREE.Vector3} normal - Center normal.
     * @param {number} radius - Circumradius (0-2).
     * @param {number} sides - Number of sides.
     * @param {Function} colorFn - (pos, t, dist) => {color, alpha}.
     * @param {Object} options - Options.
     */
    static draw(pipeline, orientation, normal, radius, sides, colorFn, phase = 0, options = {}) {
      // Fix: If radius > 1, draw a polygon on the back side by flipping normal
      if (radius > 1.0) {
        normal = normal.clone().negate();
        radius = 2.0 - radius;
      }

      const thickness = radius * (Math.PI / 2); // Map 0-1 radius to 0-PI/2 angle
      if (thickness <= 0.0001) return;

      // Basis Construction
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(normal.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }
      const v = normal.clone().applyQuaternion(orientation).normalize();
      const ref = refAxis.clone().applyQuaternion(orientation).normalize();
      const u = new THREE.Vector3().crossVectors(v, ref).normalize();
      const w = new THREE.Vector3().crossVectors(v, u).normalize();

      const nx = v.x;
      const ny = v.y;
      const nz = v.z;

      const R = Math.sqrt(nx * nx + nz * nz);
      const alpha = Math.atan2(nx, nz);

      const angle = Math.PI / sides;
      const apothem = thickness * Math.cos(angle);

      const pixelWidth = 2 * Math.PI / Daydream.W;

      const ctx = {
        normal: v, radius, thickness, sides, apothem, colorFn,
        nx, ny, nz, u, w,
        R, alpha,
        pipeline,
        pixelWidth,
        phase,
        debugBB: options.debugBB
      };

      const targetAngle = 0;
      const centerPhi = Math.acos(ny);
      const a1 = centerPhi - targetAngle;
      const a2 = centerPhi + targetAngle;
      const phiMin = Math.max(0, centerPhi - thickness - pixelWidth);
      const phiMax = Math.min(Math.PI, centerPhi + thickness + pixelWidth);

      if (phiMin > phiMax) return;

      const yMin = Math.max(0, Math.floor((phiMin * (Daydream.H - 1)) / Math.PI));
      const yMax = Math.min(Daydream.H - 1, Math.ceil((phiMax * (Daydream.H - 1)) / Math.PI));

      for (let y = yMin; y <= yMax; y++) {
        Scan.Polygon.scanRow(y, ctx);
      }
    }

    static scanRow(y, ctx) {
      // Bounding Circle Optimization
      const phi = yToPhi(y);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);

      // If near pole or singularity, scan full row (conservative)
      if (ctx.R < 0.01) {
        Scan.Polygon.scanFullRow(y, ctx);
        return;
      }

      const ang_low = 0;
      const ang_high = ctx.thickness;
      const D_max = 1.0;
      const D_min = Math.cos(ang_high);

      const denom = ctx.R * sinPhi;
      if (Math.abs(denom) < 0.000001) {
        Scan.Polygon.scanFullRow(y, ctx);
        return;
      }

      const C_min = (D_min - ctx.ny * cosPhi) / denom;
      if (C_min > 1.0) return; // Outside cap
      if (C_min < -1.0) {
        Scan.Polygon.scanFullRow(y, ctx);
        return;
      }

      const dAlpha = Math.acos(C_min);
      Scan.Polygon.scanWindow(y, ctx.alpha - dAlpha, ctx.alpha + dAlpha, ctx);
    }

    static scanFullRow(y, ctx) {
      for (let x = 0; x < Daydream.W; x++) {
        Scan.Polygon.processPixel(XY(x, y), x, y, ctx);
      }
    }

    static scanWindow(y, t1, t2, ctx) {
      const x1 = Math.floor((t1 * Daydream.W) / (2 * Math.PI));
      const x2 = Math.ceil((t2 * Daydream.W) / (2 * Math.PI));

      // Prevent double scanning if window >= 2pi
      if (x2 - x1 >= Daydream.W) {
        Scan.Polygon.scanFullRow(y, ctx);
        return;
      }

      for (let x = x1; x <= x2; x++) {
        const wx = wrap(x, Daydream.W);
        Scan.Polygon.processPixel(XY(wx, y), wx, y, ctx);
      }
    }

    static processPixel(i, x, y, ctx) {
      if (ctx.debugBB) {
        Daydream.pixels[i].r += 0.2;
        Daydream.pixels[i].g += 0.2;
        Daydream.pixels[i].b += 0.2;
      }
      const p = Daydream.pixelPositions[i];
      const polarAngle = angleBetween(p, ctx.normal);

      if (polarAngle > ctx.thickness + ctx.pixelWidth) return;

      const dotU = p.dot(ctx.u);
      const dotW = p.dot(ctx.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;
      azimuth += ctx.phase;

      // SDF Logic
      const sectorAngle = 2 * Math.PI / ctx.sides;
      // Rotate azimuth so edge is perp to x-axis
      const localAzimuth = wrap(azimuth + sectorAngle / 2, sectorAngle) - sectorAngle / 2;
      const distToEdge = polarAngle * Math.cos(localAzimuth) - ctx.apothem;

      if (distToEdge < ctx.pixelWidth) {
        // AA
        let alpha = 1.0;
        if (distToEdge > -ctx.pixelWidth) {
          const t = (distToEdge + ctx.pixelWidth) / (2 * ctx.pixelWidth);
          alpha = quinticKernel(1.0 - t);
        }

        const t = polarAngle / ctx.thickness; // Normalized distance from center
        const c = ctx.colorFn(p, t, distToEdge);
        const color = c.isColor ? c : (c.color || c);
        const baseAlpha = (c.alpha !== undefined ? c.alpha : 1.0);

        ctx.pipeline.plot2D(x, y, color, 0, baseAlpha * alpha);
      }
    }
  },

  Star: class {
    static draw(pipeline, orientation, normal, radius, sides, colorFn, phase = 0, options = {}) {
      if (radius > 1.0) {
        normal = normal.clone().negate();
        radius = 2.0 - radius; // Invert radius
      }

      // --- Shape Parameters ---
      const outerRadius = radius * (Math.PI / 2);
      const innerRadius = outerRadius * 0.382; // Pentagram ratio

      const angleStep = Math.PI / sides; // Half-sector (Tip to Valley)

      // Precompute Edge Normal for SDF
      const vT = outerRadius;
      const vVx = innerRadius * Math.cos(angleStep);
      const vVy = innerRadius * Math.sin(angleStep);
      const dx = vVx - vT;
      const dy = vVy;
      const len = Math.sqrt(dx * dx + dy * dy);

      const nx = -dy / len;
      const ny = dx / len;
      const planeD = -(nx * vT + ny * 0); // Dot(N, Tip) + D = 0 => D = -Dot

      const thickness = outerRadius;
      if (thickness <= 0.0001) return;

      const pixelWidth = 2 * Math.PI / Daydream.W;

      // Basis Construction
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(normal.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }
      const scanV = normal.clone().applyQuaternion(orientation).normalize();
      const ref = refAxis.clone().applyQuaternion(orientation).normalize();
      const u = new THREE.Vector3().crossVectors(scanV, ref).normalize();
      const w = new THREE.Vector3().crossVectors(scanV, u).normalize();
      const scanNy = scanV.y;

      const ctx = {
        scanNormal: scanV,
        u, w,
        thickness,
        sides,
        nx, ny, planeD,
        colorFn,
        pixelWidth,
        pipeline,
        phase,
        debugBB: options.debugBB
      };

      // Scan Bounding Box (around NORMAL)
      const centerPhi = Math.acos(scanNy);
      const phiMin = Math.max(0, centerPhi - thickness - pixelWidth);
      const phiMax = Math.min(Math.PI, centerPhi + thickness + pixelWidth);

      if (phiMin > phiMax) return;

      const yMin = Math.max(0, Math.floor((phiMin * (Daydream.H - 1)) / Math.PI));
      const yMax = Math.min(Daydream.H - 1, Math.ceil((phiMax * (Daydream.H - 1)) / Math.PI));

      for (let y = yMin; y <= yMax; y++) {
        Scan.Star.scanRow(y, ctx);
      }
    }

    static scanRow(y, ctx) {
      Scan.Star.scanFullRow(y, ctx);
    }

    static scanFullRow(y, ctx) {
      for (let x = 0; x < Daydream.W; x++) {
        Scan.Star.processPixel(XY(x, y), x, y, ctx);
      }
    }

    static processPixel(i, x, y, ctx) {
      const p = Daydream.pixelPositions[i];

      const scanDist = angleBetween(p, ctx.scanNormal);
      if (scanDist > ctx.thickness + ctx.pixelWidth) return;

      if (ctx.debugBB) {
        Daydream.pixels[i].r += 0.2;
        Daydream.pixels[i].g += 0.2;
        Daydream.pixels[i].b += 0.2;
      }

      const dotU = p.dot(ctx.u);
      const dotW = p.dot(ctx.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;
      azimuth += ctx.phase;

      const sectorAngle = 2 * Math.PI / ctx.sides;
      let localAzimuth = wrap(azimuth + sectorAngle / 2, sectorAngle) - sectorAngle / 2;
      localAzimuth = Math.abs(localAzimuth);

      const px = scanDist * Math.cos(localAzimuth);
      const py = scanDist * Math.sin(localAzimuth);

      const distToEdge = px * ctx.nx + py * ctx.ny + ctx.planeD;

      if (distToEdge > -ctx.pixelWidth) {
        let alpha = 1.0;
        if (distToEdge < ctx.pixelWidth) {
          const t = (distToEdge + ctx.pixelWidth) / (2 * ctx.pixelWidth);
          alpha = quinticKernel(t);
        }

        const t = scanDist / ctx.thickness;
        const c = ctx.colorFn(p, t, distToEdge);
        const color = c.isColor ? c : (c.color || c);
        const baseAlpha = (c.alpha !== undefined ? c.alpha : 1.0);

        ctx.pipeline.plot2D(x, y, color, 0, baseAlpha * alpha);
      }
    }
  },

  Flower: class {
    static draw(pipeline, orientation, normal, radius, sides, colorFn, phase = 0, options = {}) {
      // Original logic: Antipodal Polygon Distortion
      if (radius > 1.0) {
        normal = normal.clone().negate();
        radius = 2.0 - radius;
      }

      // distFromS logic (Antipodal Apothem)
      const desiredOuterRadius = radius * (Math.PI / 2);
      const apothem = Math.PI - desiredOuterRadius;

      // Calculate max extent of the "Hole" (which is the Flower) on the front
      // It is bounded by the Flats of the polygon at S, which map to Tips at Front
      // Max radius = desiredOuterRadius.
      const thickness = desiredOuterRadius;
      if (thickness <= 0.0001) return;

      // Basis Construction
      let refAxis = Daydream.X_AXIS;
      if (Math.abs(normal.dot(refAxis)) > 0.9999) {
        refAxis = Daydream.Y_AXIS;
      }
      const scanV = normal.clone().applyQuaternion(orientation).normalize();
      const ref = refAxis.clone().applyQuaternion(orientation).normalize();
      const u = new THREE.Vector3().crossVectors(scanV, ref).normalize();
      const w = new THREE.Vector3().crossVectors(scanV, u).normalize();
      const scanNy = scanV.y;

      const pixelWidth = 2 * Math.PI / Daydream.W;

      const ctx = {
        scanNormal: scanV,
        u, w,
        thickness,
        sides,
        apothem, // Antipodal Apothem
        colorFn,
        pixelWidth,
        pipeline,
        phase,
        debugBB: options.debugBB
      };

      const centerPhi = Math.acos(scanNy);
      const phiMin = Math.max(0, centerPhi - thickness - pixelWidth);
      const phiMax = Math.min(Math.PI, centerPhi + thickness + pixelWidth);

      if (phiMin > phiMax) return;

      const yMin = Math.max(0, Math.floor((phiMin * (Daydream.H - 1)) / Math.PI));
      const yMax = Math.min(Daydream.H - 1, Math.ceil((phiMax * (Daydream.H - 1)) / Math.PI));

      for (let y = yMin; y <= yMax; y++) {
        Scan.Flower.scanRow(y, ctx);
      }
    }

    static scanRow(y, ctx) {
      Scan.Flower.scanFullRow(y, ctx);
    }

    static scanFullRow(y, ctx) {
      for (let x = 0; x < Daydream.W; x++) {
        Scan.Flower.processPixel(XY(x, y), x, y, ctx);
      }
    }

    static processPixel(i, x, y, ctx) {
      const p = Daydream.pixelPositions[i];
      const scanDist = angleBetween(p, ctx.scanNormal);
      if (scanDist > ctx.thickness + ctx.pixelWidth) return;

      if (ctx.debugBB) {
        Daydream.pixels[i].r += 0.2;
        Daydream.pixels[i].g += 0.2;
        Daydream.pixels[i].b += 0.2;
      }

      // Calc distance from ANTIPODE (PI - scanDist)
      const polarAngle = Math.PI - scanDist;

      const dotU = p.dot(ctx.u);
      const dotW = p.dot(ctx.w);
      let azimuth = Math.atan2(dotW, dotU);
      if (azimuth < 0) azimuth += 2 * Math.PI;
      azimuth += ctx.phase;
      const sectorAngle = 2 * Math.PI / ctx.sides;
      const localAzimuth = wrap(azimuth + sectorAngle / 2, sectorAngle) - sectorAngle / 2;

      // SDF vs Antipodal Polygon
      const distToEdge = polarAngle * Math.cos(localAzimuth) - ctx.apothem;

      // If distToEdge > 0, we are OUTSIDE the polygon at S.
      // This forms the "Hole" or "Flower" at N.

      if (distToEdge > -ctx.pixelWidth) {
        let alpha = 1.0;
        if (distToEdge < ctx.pixelWidth) {
          const t = (distToEdge + ctx.pixelWidth) / (2 * ctx.pixelWidth);
          alpha = quinticKernel(t);
        }

        const t = scanDist / ctx.thickness;
        const c = ctx.colorFn(p, t, distToEdge);
        const color = c.isColor ? c : (c.color || c);
        const baseAlpha = (c.alpha !== undefined ? c.alpha : 1.0);

        ctx.pipeline.plot2D(x, y, color, 0, baseAlpha * alpha);
      }
    }
  },

  Circle: class {
    /**
     * Scans a solid circle (disk) on the sphere.
     * @param {Object} pipeline - Render pipeline.
     * @param {THREE.Vector3} normal - Center of the circle.
     * @param {number} radius - Angular radius (0-2).
     * @param {Function} colorFn - (pos, t, dist) => {color, alpha}.
     * @param {Object} options - Options.
     */
    static draw(pipeline, normal, radius, colorFn, options = {}) {
      // A circle is a ring with radius 0 and thickness = radius
      const thickness = radius * (Math.PI / 2);
      Scan.Ring.draw(pipeline, normal, 0, thickness, colorFn, 0, 2 * Math.PI, options);
    }
  },

  Ring: class {
    /**
     * Scans a thick ring and feeds pixels into the pipeline.
     * @param {Object} pipeline - The render pipeline (must support plot2D).
     * @param {Array} pixels - The pixel buffer (Daydream.pixels).
     * @param {THREE.Vector3} normal - Ring orientation.
     * @param {number} radius - Angular radius (0-2).
     * @param {number} thickness - Angular thickness.
     * @param {Function} materialFn - (pos, t, dist) => {color, alpha}.
     * @param {number} [startAngle=0] - Start of the arc in radians.
     * @param {number} [endAngle=6.28318] - End of the arc in radians.
     */
    static draw(pipeline, normal, radius, thickness, colorFn, startAngle = 0, endAngle = 2 * Math.PI, options = {}) {
      // Pre-calculate properties
      const nx = normal.x;
      const ny = normal.y;
      const nz = normal.z;

      // Basis
      let ref = new THREE.Vector3(1, 0, 0); // X_AXIS
      if (Math.abs(normal.dot(ref)) > 0.9999) {
        ref.set(0, 1, 0); // Y_AXIS
      }
      const u = new THREE.Vector3().crossVectors(normal, ref).normalize();
      const w = new THREE.Vector3().crossVectors(normal, u).normalize();

      const targetAngle = radius * (Math.PI / 2);
      const R = Math.sqrt(nx * nx + nz * nz);
      const alpha = Math.atan2(nx, nz);
      const centerPhi = Math.acos(ny);

      const angMin = Math.max(0, targetAngle - thickness);
      const angMax = Math.min(Math.PI, targetAngle + thickness);
      const cosMax = Math.cos(angMin); // Smaller angle = Larger cosine
      const cosMin = Math.cos(angMax);

      const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI - 0.001;

      const cosTarget = Math.cos(targetAngle);
      const sinTarget = Math.sin(targetAngle);
      const invSinTarget = Math.abs(sinTarget) > 0.001 ? 1.0 / sinTarget : 0;

      const ctx = {
        normal, radius, thickness, colorFn,
        nx, ny, nz, targetAngle, R, alpha, centerPhi,
        cosMin, cosMax, // Optimization
        cosTarget, invSinTarget, // Optimization (polarAngle)
        u, w, startAngle, endAngle,
        checkSector: !isFullCircle,
        computeT: options.computeT !== undefined ? options.computeT : true, // Optimization for RingSpin
        pipeline,
        clipPlanes: options.clipPlanes, // Injected options
        limits: options.limits, // Injected options
        debugBB: options.debugBB // Injected options
      };

      // Vertical bounds
      const a1 = centerPhi - targetAngle;
      const a2 = centerPhi + targetAngle;
      const p1 = Math.acos(Math.cos(a1));
      const p2 = Math.acos(Math.cos(a2));
      const minP = Math.min(p1, p2);
      const maxP = Math.max(p1, p2);

      let phiMin = Math.max(0, minP - thickness);
      let phiMax = Math.min(Math.PI, maxP + thickness);

      if (ctx.limits) {
        phiMin = Math.max(phiMin, ctx.limits.minPhi);
        phiMax = Math.min(phiMax, ctx.limits.maxPhi);
      }

      if (phiMin > phiMax) return;

      const yMin = Math.max(0, Math.floor((phiMin * (Daydream.H - 1)) / Math.PI));
      const yMax = Math.min(Daydream.H - 1, Math.ceil((phiMax * (Daydream.H - 1)) / Math.PI));

      for (let y = yMin; y <= yMax; y++) {
        Scan.Ring.scanRow(y, ctx);
      }
    }

    static scanRow(y, ctx) {
      const phi = yToPhi(y);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);

      if (ctx.R < 0.01) {
        Scan.Ring.scanFullRow(y, ctx);
        return;
      }

      const ang_low = Math.max(0, ctx.targetAngle - ctx.thickness);
      const ang_high = Math.min(Math.PI, ctx.targetAngle + ctx.thickness);
      const D_max = Math.cos(ang_low);
      const D_min = Math.cos(ang_high);
      const denom = ctx.R * sinPhi;

      if (Math.abs(denom) < 0.000001) {
        Scan.Ring.scanFullRow(y, ctx);
        return;
      }

      const C_min = (D_min - ctx.ny * cosPhi) / denom;
      const C_max = (D_max - ctx.ny * cosPhi) / denom;
      const minCos = Math.max(-1, C_min);
      const maxCos = Math.min(1, C_max);

      if (minCos > maxCos) return;

      const angleMin = Math.acos(maxCos);
      const angleMax = Math.acos(minCos);
      const pixelWidth = 2 * Math.PI / Daydream.W;
      const safeThreshold = pixelWidth;

      if (angleMin <= safeThreshold) {
        Scan.Ring.scanWindow(y, ctx.alpha - angleMax, ctx.alpha + angleMax, ctx);
      } else if (angleMax >= Math.PI - safeThreshold) {
        Scan.Ring.scanWindow(y, ctx.alpha + angleMin, ctx.alpha + 2 * Math.PI - angleMin, ctx);
      } else {
        Scan.Ring.scanWindow(y, ctx.alpha - angleMax, ctx.alpha - angleMin, ctx);
        Scan.Ring.scanWindow(y, ctx.alpha + angleMin, ctx.alpha + angleMax, ctx);
      }
    }

    static scanFullRow(y, ctx) {
      for (let x = 0; x < Daydream.W; x++) {
        Scan.Ring.processPixel(XY(x, y), x, y, ctx);
      }
    }

    static scanWindow(y, t1, t2, ctx) {
      const x1 = Math.floor((t1 * Daydream.W) / (2 * Math.PI));
      const x2 = Math.ceil((t2 * Daydream.W) / (2 * Math.PI));

      // Prevent double scanning if window >= 2pi
      if (x2 - x1 >= Daydream.W) {
        Scan.Ring.scanFullRow(y, ctx);
        return;
      }

      for (let x = x1; x <= x2; x++) {
        const wx = wrap(x, Daydream.W);
        Scan.Ring.processPixel(XY(wx, y), wx, y, ctx);
      }
    }

    static processPixel(i, x, y, ctx) {
      if (ctx.debugBB) {
        const outColor = Daydream.pixels[i];
        outColor.r += 0.02; outColor.g += 0.02; outColor.b += 0.02;
      }

      const p = Daydream.pixelPositions[i];

      if (ctx.clipPlanes) {
        for (const cp of ctx.clipPlanes) {
          if (p.dot(cp) < 0) return;
        }
      }

      // Optimization: Fast Rejection via Dot Product
      const dot = p.dot(ctx.normal);
      if (ctx.cosMin !== undefined) {
        if (dot < ctx.cosMin || dot > ctx.cosMax) return;
      }

      let dist = 0;
      if (ctx.invSinTarget !== 0) {
        // Optimization: Linear approximation of acos near targetAngle
        // dist ~= |dot - cos(target)| / sin(target)
        dist = Math.abs(dot - ctx.cosTarget) * ctx.invSinTarget;
      } else {
        const polarAngle = Math.acos(Math.max(-1, Math.min(1, dot)));
        dist = Math.abs(polarAngle - ctx.targetAngle);
      }

      if (dist < ctx.thickness) {

        const distT = dist / ctx.thickness;
        const aaAlpha = quinticKernel(1.0 - distT);

        // Calculate azimuth for t and/or sector check
        let t = 0;

        if (ctx.checkSector || ctx.computeT) {
          const dotU = p.dot(ctx.u);
          const dotW = p.dot(ctx.w);
          let azimuth = Math.atan2(dotW, dotU);
          if (azimuth < 0) azimuth += 2 * Math.PI;

          if (ctx.checkSector) {
            let inside = false;
            if (ctx.startAngle <= ctx.endAngle) {
              inside = (azimuth >= ctx.startAngle && azimuth <= ctx.endAngle);
            } else {
              inside = (azimuth >= ctx.startAngle || azimuth <= ctx.endAngle);
            }
            if (!inside) return;
          }

          if (ctx.computeT) {
            // Normalize t based on angle range
            if (Math.abs(ctx.endAngle - ctx.startAngle) > 0.0001) {
              let relAz = azimuth - ctx.startAngle;
              // handle wrap for sector crossing 0
              if (ctx.startAngle > ctx.endAngle && relAz < 0) relAz += 2 * Math.PI;
              t = relAz / (ctx.startAngle > ctx.endAngle ? (2 * Math.PI - (ctx.startAngle - ctx.endAngle)) : (ctx.endAngle - ctx.startAngle));
            } else {
              t = azimuth / (2 * Math.PI);
            }
          }
        }

        // Evaluate Material
        const c = ctx.colorFn(p, t, dist);
        const color = c.isColor ? c : (c.color || c);
        const baseAlpha = (c.alpha !== undefined ? c.alpha : 1.0);

        ctx.pipeline.plot2D(x, y, color, 0, baseAlpha * aaAlpha);
      }
    }
  },

  Line: class {
    static draw(pipeline, pixels, v1, v2, thickness, colorFn, options = {}) {
      const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
      if (normal.lengthSq() < 0.000001) return;

      const c1 = new THREE.Vector3().crossVectors(normal, v1);
      const c2 = new THREE.Vector3().crossVectors(v2, normal);

      let maxY = Math.max(v1.y, v2.y);
      let minY = Math.min(v1.y, v2.y);
      const apexPlaneNormal = new THREE.Vector3().crossVectors(normal, new THREE.Vector3(0, 1, 0));
      if (apexPlaneNormal.lengthSq() > 0.0001) {
        const d1 = v1.dot(apexPlaneNormal);
        const d2 = v2.dot(apexPlaneNormal);
        if (d1 * d2 <= 0) {
          const globalMaxY = Math.sqrt(1 - normal.y * normal.y);
          if (v1.y + v2.y > 0) maxY = globalMaxY;
          else minY = -globalMaxY;
        }
      }

      const minPhi = Math.acos(Math.min(1, Math.max(-1, maxY))) - thickness;
      const maxPhi = Math.acos(Math.min(1, Math.max(-1, minY))) + thickness;

      Scan.Ring.draw(pipeline, normal, 1.0, thickness, colorFn, 0, 2 * Math.PI, {
        ...options,
        clipPlanes: [c1, c2],
        limits: { minPhi, maxPhi }
      });
    }
  },

  Point: class {
    static draw(pipeline, pos, thickness, colorFn, options) {
      Scan.Ring.draw(pipeline, pos, 0, thickness, colorFn, 0, 2 * Math.PI, options);
    }
  },

  Field: class {
    static draw(pipeline, colorFn) {
      for (let i = 0; i < Daydream.pixelPositions.length; i++) {
        const x = i % Daydream.W;
        const y = (i / Daydream.W) | 0;

        const p = Daydream.pixelPositions[i];
        const mat = colorFn(p);

        const color = mat.isColor ? mat : (mat.color || mat);
        const alpha = (mat.alpha !== undefined ? mat.alpha : 1.0);

        if (pipeline.plot) {
          pipeline.plot(p, color, 0, alpha);
        } else if (pipeline.plot2D) {
          pipeline.plot2D(x, y, color, 0, alpha);
        }
      }
    }
  }
};