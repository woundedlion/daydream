// draw.js
import * as THREE from "three";
import { Daydream, labels } from "./driver.js";
import { Dot, angleBetween, fibSpiral } from "./geometry.js";

/**
 * Implements pixel history and decay for persistent effects.
 */
export class DecayBuffer {
  /**
   * @param {number} lifespan - The number of frames a pixel lasts.
   */
  constructor(lifespan) {
    this.lifespan = lifespan;
    this.history = [];
  }

  /**
   * Records a list of dots into the history buffer.
   * @param {Dot[]} dots - The list of dots to record.
   * @param {number} age - The initial age of the dots
   * @param {number} alpha - The opacity of the dots.
   */
  recordDots(dots, age, alpha) {
    for (const dot of dots) {
      this.record(dot.position, dot.color, age, alpha);
    }
  }

  /**
   * Records a single dot into the history buffer.
   * @param {THREE.Vector3} v - The position vector.
   * @param {THREE.Color} color - The color of the dot.
   * @param {number} age - The initial age of the dot.
   * @param {number} alpha - The opacity of the dot.
   */
  record(v, color, age, alpha) {
    this.history.push({ v: v, color: color, alpha: alpha, ttl: this.lifespan - age })
  }

  /**
   * Renders the buffered dots to the pixel map, applying decay.
   * @param {Map} pixels - The pixel map to write to.
   * @param {Object} pipeline - The render pipeline or filter object.
   * @param {Function} colorFn - Function to determine color based on decay (takes vector and normalized decay progress 0-1).
   */
  render(pixels, pipeline, colorFn) {
    for (let i = 0; i < this.history.length; ++i) {
      // plot
      let e = this.history[i];
      if (e.ttl === this.lifespan) {
        pipeline.plot(pixels, e.v, e.color, 0, e.alpha);
      } else if (e.ttl > 0) {
        pipeline.plot(pixels, e.v, colorFn(e.v, (this.lifespan - e.ttl) / this.lifespan), 0, e.alpha);
      }

      // decay and cleanup
      if (--e.ttl <= 0) {
        this.history.splice(i, 1);
        i--;
      }
    }
  }
}

/**
 * Represents a path composed of connected points on the sphere.
 */
export class Path {
  /**
   * @param {THREE.Vector3} initialPos - The starting position of the path.
   */
  constructor(initialPos) {
    this.points = [initialPos];
  }

  /**
   * Collapses the path to only the last point.
   */
  collapse() {
    this.points = [this.points[this.points.length - 1]];
  }

  /**
   * Gets the number of points in the path.
   * @returns {number} The length of the path.
   */
  length() {
    return this.points.length;
  }

  /**
   * Appends a line segment between two vectors to the path.
   * @param {THREE.Vector3} c1 - The start vector.
   * @param {THREE.Vector3} c2 - The end vector.
   * @param {boolean} [longWay=false] - If true, take the longer arc.
   * @param {Function} [easingFn=(t) => t] - An unused easing function (retained for signature).
   * @returns {Path} The path instance.
   */
  appendLine(c1, c2, longWay = false, easingFn = (t) => t) {
    if (this.points.length > 0) {
      this.points.pop();
    }
    this.points.push(
      ...drawLine(c1, c2, (v, t) => undefined, 0, 1, longWay)
        .map((d) => d.position));
    return this;
  }

  /**
   * Appends a segment generated by a plotting function.
   * @param {Function} plotFn - Function that returns a vector based on a domain parameter t.
   * @param {number} domain - The range of the input parameter for plotFn.
   * @param {number} samples - The number of points to sample.
   * @param {Function} [easingFn=(t) => t] - The easing function to apply to the input parameter.
   * @returns {Path} The path instance.
   */
  appendSegment(plotFn, domain, samples, easingFn = (t) => t) {
    if (this.points.length > 0) {
      this.points.pop();
    }
    for (let t = 0; t <= samples; t++) {
      this.points.push(plotFn(easingFn(t / samples) * domain));
    }
    return this;
  }

  /**
   * Gets a point on the path based on a normalized parameter t.
   * @param {number} t - Normalized position along the path [0, 1].
   * @returns {THREE.Vector3} A clone of the point at the given position.
   */
  getPoint(t) {
    let i = Math.floor(t * (this.points.length - 1));
    return this.points[i].clone();
  }
}

/**
 * Represents a path defined by a single procedural function.
 */
export class ProceduralPath {
  /**
   * @param {Function} pathFn - Function that takes a parameter t [0, 1] and returns a THREE.Vector3.
   */
  constructor(pathFn) {
    this.f = pathFn;
  }

  /**
   * Gets a point on the path.
   * @param {number} t - Normalized position along the path [0, 1].
   * @returns {THREE.Vector3} The point on the path.
   */
  getPoint(t) {
    return this.f(t);
  }
}

/**
 * Draws a single dot at a given vector.
 * @param {THREE.Vector3} v - The vector position (normalized).
 * @param {Function} colorFn - Function to determine the color (takes vector and t=0).
 * @returns {Dot[]} An array containing a single Dot.
 */
export const drawVector = (v, colorFn) => {
  return [new Dot(new THREE.Vector3(...v.toArray()).normalize(), colorFn(v, 0))];
}

/**
 * Draws a sequence of points along a Path object.
 * @param {Path|ProceduralPath} path - The path object.
 * @param {Function} colorFn - Function to determine the color (takes normalized time t).
 * @returns {Dot[]} An array of Dots along the path.
 */
export const drawPath = (path, colorFn) => {
  let r = [];
  for (let t = 0; t < path.length(); t++) {
    r.push(new Dot(path.getPoint(t / path.length()), colorFn(t)));
  }
  return r;
}

/**
 * Draws a geodesic line (arc) between two vectors on the sphere.
 * @param {THREE.Vector3} v1 - The start vector.
 * @param {THREE.Vector3} v2 - The end vector.
 * @param {Function} colorFn - Function to determine the color (takes vector and normalized progress t).
 * @param {number} [start=0] - Starting angle multiplier for drawing the line arc.
 * @param {number} [end=1] - Ending multiplier for the total arc angle.
 * @param {boolean} [longWay=false] - If true, draws the longer arc.
 * @returns {Dot[]} An array of Dots forming the line.
 */
export const drawLine = (v1, v2, colorFn, start = 0, end = 1, longWay = false) => {
  let u = v1.clone();
  let v = v2.clone();
  let a = angleBetween(u, v);
  let w = new THREE.Vector3();

  if (Math.abs(a) < 0.0001) {
    return [new Dot(u, colorFn(u, 1))];
  } else if (Math.abs(Math.PI - a) < 0.0001) {
    if (Math.abs(v.dot(Daydream.X_AXIS)) > 0.9999) {
      w.crossVectors(u, Daydream.Y_AXIS).normalize();
    } else {
      w.crossVectors(u, Daydream.X_AXIS).normalize();
    }
  } else {
    w.crossVectors(u, v).normalize();
  }

  if (longWay) {
    a = 2 * Math.PI - a;
    w.negate();
  }

  if (start != 0) {
    let q = new THREE.Quaternion().setFromAxisAngle(w, start * a);
    u.applyQuaternion(q).normalize();
  }
  a *= Math.abs(end - start);

  let dots = []
  let numSteps = Math.max(1, Math.ceil((a / (2 * Math.PI)) * Daydream.W * 2));
  let q = new THREE.Quaternion().setFromAxisAngle(w, a / numSteps);
  for (let i = 0; i <= numSteps; ++i) {
    dots.push(new Dot(u.clone(), colorFn(u, i / numSteps)));
    u.applyQuaternion(q).normalize();
  }
  return dots;
}

/**
 * Draws a set of vertices as individual dots.
 * @param {number[][]} vertices - An array of [x, y, z] arrays.
 * @param {Function} colorFn - Function to determine the color (takes vector).
 * @returns {Dot[]} An array of Dots at the vertex positions.
 */
export const drawVertices = (vertices, colorFn) => {
  let dots = [];
  let v = new THREE.Vector3();
  for (const vertex of vertices) {
    v.set(vertex[0], vertex[1], vertex[2]);
    dots.push(new Dot(v.normalize(), colorFn(v)));
  }
  return dots;
}

/**
 * Draws the edges of a polyhedron by drawing lines between connected vertices.
 * @param {number[][]} vertices - An array of [x, y, z] vertex arrays.
 * @param {number[][]} edges - An adjacency list of vertex indices.
 * @param {Function} colorFn - Function to determine the color (takes vector and normalized progress t).
 * @returns {Dot[]} An array of Dots forming the edges.
 */
export const drawPolyhedron = (vertices, edges, colorFn) => {
  let dots = [];
  edges.map((adj, i) => {
    adj.map((j) => {
      dots.push(
        ...drawLine(
          new THREE.Vector3(...vertices[i]).normalize(),
          new THREE.Vector3(...vertices[j]).normalize(),
          colorFn)
      );
    })
  });
  return dots;
}

/**
 * Calculates a single point on a sphere distorted by a function, often for an oscillating ring.
 * @param {Function} f - The shift function (e.g., sinWave) based on angle.
 * @param {THREE.Vector3} normal - The normal vector defining the ring plane.
 * @param {number} radius - The base radius of the ring.
 * @param {number} angle - The angle along the ring to calculate the point.
 * @returns {THREE.Vector3} The shifted point on the sphere.
 */
export const fnPoint = (f, normal, radius, angle) => {
  let dots = [];
  let u = new THREE.Vector3();
  let v = normal.clone();
  let w = new THREE.Vector3();
  if (radius > 1) {
    v.negate();
    radius = 2 - radius;
  }
  if (Math.abs(v.dot(Daydream.X_AXIS)) > 0.99995) {
    u.crossVectors(v, Daydream.Y_AXIS).normalize();
  } else {
    u.crossVectors(v, Daydream.X_AXIS).normalize();
  }
  w.crossVectors(v, u);
  let d = Math.sqrt(Math.pow(1 - radius, 2));

  let vi = calcRingPoint(angle, radius, u, v, w);
  let vp = calcRingPoint(angle, 1, u, v, w);
  let axis = new THREE.Vector3().crossVectors(v, vp).normalize();
  let shift = new THREE.Quaternion().setFromAxisAngle(axis, f(angle * Math.PI / 2));
  return vi.clone().applyQuaternion(shift);
};

/**
 * Draws a function-distorted ring with adaptive sampling.
 * @param {THREE.Quaternion} orientationQuaternion - Orientation of the base ring.
 * @param {THREE.Vector3} normal - Normal of the base ring.
 * @param {number} radius - Base radius (0-1).
 * @param {Function} shiftFn - Function(t) returning angle offset.
 * @param {Function} colorFn - Function(v, t) returning color.
 * @param {number} [phase=0] - Starting phase offset.
 */
export const drawFn = (orientationQuaternion, normal, radius, shiftFn, colorFn, phase = 0) => {
  // Basis
  let refAxis = Daydream.X_AXIS;
  if (Math.abs(normal.dot(refAxis)) > 0.9999) {
    refAxis = Daydream.Y_AXIS;
  }
  let v = normal.clone().applyQuaternion(orientationQuaternion).normalize();
  let ref = refAxis.clone().applyQuaternion(orientationQuaternion).normalize();
  let u = new THREE.Vector3().crossVectors(v, ref).normalize();
  let w = new THREE.Vector3().crossVectors(v, u).normalize();

  // Backside rings
  let vSign = 1.0;
  if (radius > 1) {
    vSign = -1.0;
    radius = 2 - radius;
  }

  // Equidistant projection
  const thetaEq = radius * (Math.PI / 2);
  const r = Math.sin(thetaEq);
  const d = Math.cos(thetaEq);

  // Calculate Samples
  const baseStep = 2 * Math.PI / Daydream.W;
  let points = [];
  let thetas = [];
  let theta = 0;
  let uTemp = new THREE.Vector3();
  while (true) {
    let t = theta + phase;
    let cosRing = Math.cos(t);
    let sinRing = Math.sin(t);
    uTemp.copy(u).multiplyScalar(cosRing).addScaledVector(w, sinRing);

    // Apply Shift
    let shift = shiftFn(theta / (2 * Math.PI));
    let cosShift = Math.cos(shift);
    let sinShift = Math.sin(shift);
    let vScale = (vSign * d) * cosShift - r * sinShift;
    let uScale = r * cosShift + (vSign * d) * sinShift;
    let p = v.clone().multiplyScalar(vScale).addScaledVector(uTemp, uScale).normalize();

    points.push(p);
    //    labels.push({ position: p, content: (t / (2 * Math.PI)).toFixed(1)});
    thetas.push(theta);

    // Adaptive Sampling for horizontal pixel distortion at poles
    let scaleFactor = Math.max(0.05, Math.sqrt(Math.max(0, 1.0 - p.y * p.y)));
    let step = baseStep * scaleFactor;
    let nextTheta = theta + step;

    // Repair last N samples to close the loop
    if (nextTheta >= 2 * Math.PI) {
      const REPAIR_COUNT = 5;
      if (points.length > REPAIR_COUNT) {
        //      labels.length - + REPAIR_COUNT;
        const targetLastTheta = 2 * Math.PI - step;
        const anchorIdx = points.length - REPAIR_COUNT - 1;
        const anchorTheta = thetas[anchorIdx];
        const currentLastTheta = theta;
        const ratio = (targetLastTheta - anchorTheta) / (currentLastTheta - anchorTheta);
        for (let i = anchorIdx + 1; i < points.length; i++) {
          const dist = thetas[i] - anchorTheta;
          const correctedTheta = anchorTheta + (dist * ratio);

          // Re-calculate Geometry
          let t = correctedTheta + phase;
          let cosRing = Math.cos(t);
          let sinRing = Math.sin(t);
          uTemp.copy(u).multiplyScalar(cosRing).addScaledVector(w, sinRing);

          // Re-apply Shift
          let shift = shiftFn(correctedTheta / (2 * Math.PI));
          let cosShift = Math.cos(shift);
          let sinShift = Math.sin(shift);
          let vScale = (vSign * d) * cosShift - r * sinShift;
          let uScale = r * cosShift + (vSign * d) * sinShift;
          points[i].copy(v).multiplyScalar(vScale).addScaledVector(uTemp, uScale).normalize();
          //          labels.push({ position:points[i], content: (t / (2 * Math.PI)).toFixed(1) });
        }
      }
      break;
    }
    theta = nextTheta;
  }

  // Draw lines connecting the repaired points
  let finalDots = [];
  for (let i = 0; i < points.length; ++i) {
    let nextI = (i + 1) % points.length;
    let tStart = thetas[i] / (2 * Math.PI);
    let segmentDots = drawLine(points[i], points[nextI],
      (vec, lineT) => {
        return colorFn(vec, tStart);
      });
    segmentDots.pop(); // Avoid drawing over the start vertex
    finalDots.push(...segmentDots);
  }

  return finalDots;
}

/**
 * Calculates a point on a circle that lies on the surface of the unit sphere.
 * Used internally by drawing functions.
 * @param {number} a - The angle in radians around the ring.
 * @param {number} radius - The ring radius in the plane.
 * @param {THREE.Vector3} u - A vector on the plane (ortho to normal).
 * @param {THREE.Vector3} v - The ring's normal (center point).
 * @param {THREE.Vector3} w - A second vector on the plane (ortho to u and normal).
 * @returns {THREE.Vector3} The normalized point on the sphere's surface.
 */
export const calcRingPoint = (a, radius, u, v, w) => {
  let d = Math.sqrt(Math.pow(1 - radius, 2));
  return new THREE.Vector3(
    d * v.x + radius * u.x * Math.cos(a) + radius * w.x * Math.sin(a),
    d * v.y + radius * u.y * Math.cos(a) + radius * w.y * Math.sin(a),
    d * v.z + radius * u.z * Math.cos(a) + radius * w.z * Math.sin(a)
  ).normalize();
}

/**
 * Draws a circular ring on the sphere surface with adaptive sampling
 * to prevent artifacts near the poles.
 * @param {THREE.Quaternion} orientationQuaternion - The orientation of the ring.
 * @param {THREE.Vector3} normal - The normal vector defining the ring plane.
 * @param {number} radius - The radius of the ring.
 * @param {Function} colorFn - Function to determine color.
 * @param {number} [phase=0] - Starting phase.
 * @returns {Dot[]} An array of Dots.
 */
export const drawRing = (orientationQuaternion, normal, radius, colorFn, phase = 0) => {
  // Basis
  let refAxis = Daydream.X_AXIS;
  if (Math.abs(normal.dot(refAxis)) > 0.9999) {
    refAxis = Daydream.Y_AXIS;
  }
  let v = normal.clone().applyQuaternion(orientationQuaternion).normalize();
  let ref = refAxis.clone().applyQuaternion(orientationQuaternion).normalize();
  let u = new THREE.Vector3().crossVectors(v, ref).normalize();
  let w = new THREE.Vector3().crossVectors(v, u).normalize();

  // Backside rings
  let vDir = v.clone();
  if (radius > 1) {
    vDir.negate();
    radius = 2 - radius;
  }

  // Equidistant projection 
  const thetaEq = radius * (Math.PI / 2);
  const r = Math.sin(thetaEq);
  const d = Math.cos(thetaEq);

  // Calculate Samples
  const baseStep = 2 * Math.PI / Daydream.W;
  let dots = [];
  let thetas = [];
  let theta = 0;
  let uTemp = new THREE.Vector3();
  while (true) {
    let t = theta + phase;
    let cosRing = Math.cos(t);
    let sinRing = Math.sin(t);
    uTemp.copy(u).multiplyScalar(cosRing).addScaledVector(w, sinRing);
    let p = vDir.clone().multiplyScalar(d).addScaledVector(uTemp, r).normalize();
    dots.push(new Dot(p, colorFn(p, t / (2 * Math.PI))));
    thetas.push(theta);

    // Adaptive Sampling for horizontal pixel distortion at poles
    let scaleFactor = Math.max(0.05, Math.sqrt(Math.max(0, 1.0 - p.y * p.y)));
    let step = baseStep * scaleFactor;
    let nextTheta = theta + step;

    // Repair last N samples to close the loop
    if (nextTheta >= 2 * Math.PI) {
      const REPAIR_COUNT = 5;
      if (dots.length > REPAIR_COUNT) {
        const targetLastTheta = 2 * Math.PI - step;
        const anchorIdx = dots.length - REPAIR_COUNT - 1;
        const anchorTheta = thetas[anchorIdx];
        const currentLastTheta = theta;
        const ratio = (targetLastTheta - anchorTheta) / (currentLastTheta - anchorTheta);
        for (let i = anchorIdx + 1; i < dots.length; i++) {
          const dist = thetas[i] - anchorTheta;
          const correctedTheta = anchorTheta + (dist * ratio);

          // Re-calculate Geometry
          let t = correctedTheta + phase;
          let cosRing = Math.cos(t);
          let sinRing = Math.sin(t);
          uTemp.copy(u).multiplyScalar(cosRing).addScaledVector(w, sinRing);
          dots[i].position.copy(vDir).multiplyScalar(d).addScaledVector(uTemp, r).normalize();
          dots[i].color = colorFn(dots[i].position, t / (2 * Math.PI));
        }
      }
      break;
    }
    theta = nextTheta;
  }
  return dots;
}

export const ringPoint = (normal, radius, angle, phase = 0) => {
  let dots = [];
  let u = new THREE.Vector3();
  let v = normal.clone();
  let w = new THREE.Vector3();
  if (radius > 1) {
    v.negate();
  }
  if (Math.abs(v.dot(Daydream.X_AXIS)) > 0.99995) {
    u.crossVectors(v, Daydream.Y_AXIS).normalize();
  } else {
    u.crossVectors(v, Daydream.X_AXIS).normalize();
  }
  w.crossVectors(v, u);
  if (radius > 1) {
    w.negate();
    radius = 2 - radius;
  }
  let d = Math.sqrt(Math.pow(1 - radius, 2));
  return new THREE.Vector3(
    d * v.x + radius * u.x * Math.cos(angle + phase) + radius * w.x * Math.sin(angle + phase),
    d * v.y + radius * u.y * Math.cos(angle + phase) + radius * w.y * Math.sin(angle + phase),
    d * v.z + radius * u.z * Math.cos(angle + phase) + radius * w.z * Math.sin(angle + phase)
  ).normalize();
};

/**
 * Draws points forming a Fibonacci spiral pattern.
 * @param {number} n - Total number of points.
 * @param {number} eps - Epsilon value for spiral offset.
 * @param {Function} colorFn - Function to determine the color (takes vector).
 * @returns {Dot[]} An array of Dots forming the spiral.
 */
export const drawFibSpiral = (n, eps, colorFn) => {
  let dots = [];
  for (let i = 0; i < n; ++i) {
    let v = fibSpiral(n, eps, i);
    dots.push(new Dot(v, colorFn(v)));
  }
  return dots;
};

/**
 * Plots a list of dots onto the pixel map using the provided filters.
 * @param {Map} pixels - The pixel map.
 * @param {Object} filters - The render pipeline or filter object.
 * @param {Dot[]} dots - The array of dots to plot.
 * @param {number} age - The initial age of the dot.
 * @param {number} alpha - The global opacity for these dots.
 */
export function plotDots(pixels, filters, dots, age, alpha) {
  for (const dot of dots) {
    filters.plot(pixels, dot.position, dot.color, age, alpha);
  }
}

/**
 * Draws a motion trail by tweening between orientations in the queue.
 * @param {Orientation} orientation - The orientation object containing the motion history.
 * @param {Function} drawFn - Function to draw a segment (takes orientation quaternion and normalized age/opacity).
 */
export const tween = (orientation, drawFn) => {
  let s = orientation.length();
  let start = (s > 1) ? 1 : 0;
  for (let i = start; i < s; ++i) {
    drawFn(orientation.get(i), (s - 1 - i) / s);
  }
}