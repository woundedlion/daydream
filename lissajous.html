<!DOCTYPE html>
<!--
 Required Notice: Copyright 2025 Gabriel Levy. All rights reserved.
 Licensed under the Polyform Noncommercial License 1.0.0
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spherical Lissajous Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <style>
        /* Custom styles inspired by palettes.html */
        :root {
            --slate-900: #0f172a;
            --slate-800: #1e293b;
            --slate-700: #334155;
            --blue-500: #3b82f6;
            --indigo-400: #818cf8;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--slate-900);
            color: #E2E8F0;
            overflow: hidden;
            /* Prevent scrolling */
        }

        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            /* FIX: Dynamically calculate the width to exclude the fixed controls panel */
            width: calc(100vw - 420px);
            height: 100vh;
            z-index: 10;
        }

        #controls {
            position: fixed;
            top: 0;
            right: 0;
            height: 100vh;
            z-index: 20;
            width: 420px;
            max-width: 100vw;
            padding: 1.5rem;
            background-color: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            overflow-y: auto;
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.4);
            border-left: 1px solid var(--slate-700);
        }

        /* Styling for the parameter groups */
        .param-group {
            background-color: var(--slate-700);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Custom slider styles */
        input[type=range] {
            height: 6px;
            -webkit-appearance: none;
            width: 100%;
            background: #475569;
            border-radius: 3px;
            cursor: pointer;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--blue-500);
            cursor: pointer;
            margin-top: 3px;
            /* ADJUSTED: Moved down by 8px from -5px */
        }

        /* Style for disabled slider thumb */
        input[type=range]:disabled::-webkit-slider-thumb {
            background: var(--slate-800);
            cursor: default;
        }

        input[type=range]:disabled {
            background: #47556950;
        }

        .slider-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            color: var(--indigo-400);
        }

        /* Media query for smaller screens */
        @media (max-width: 640px) {
            #controls {
                width: 100vw;
                height: 50vh;
                top: auto;
                bottom: 0;
                border-top: 1px solid var(--slate-700);
                border-left: none;
                box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.4);
            }

            #canvasContainer {
                height: 50vh;
                width: 100vw;
                /* On mobile, use full width */
            }

            body {
                overflow-y: scroll;
                /* Allow scrolling on mobile controls */
            }
        }
    </style>
</head>

<body>
    <div id="canvasContainer">
        <canvas id="threeCanvas" class="w-full h-full"></canvas>
    </div>

    <div id="controls" class="space-y-6">
        <h1 class="text-3xl font-bold text-white text-center">Lissajous Visualizer</h1>
        <p class="text-sm text-gray-400 text-center">
            Spherical Lissajous Curve (on unit sphere): F(t) = (R sin(C₂t) cos(C₁t - A), R cos(C₂t), R sin(C₂t) sin(C₁t
            - A))
        </p>

        <div id="sliders">
            <div class="param-group">
                <h3 class="text-xl font-semibold text-indigo-400">Frequency C₁ (Axial)</h3>
                <div id="C1_container" class="flex items-center space-x-3 mt-2"></div>
            </div>

            <div class="param-group">
                <h3 class="text-xl font-semibold text-indigo-400">Frequency C₂ (Orbital)</h3>
                <div id="C2_container" class="flex items-center space-x-3 mt-2"></div>
            </div>

            <div class="param-group">
                <h3 class="text-xl font-semibold text-indigo-400">Phase Shift A (radians)</h3>
                <div id="A_container" class="flex items-center space-x-3 mt-2"></div>
            </div>

            <div class="param-group">
                <h3 class="text-xl font-semibold text-indigo-400">Rendering</h3>

                <!-- CHECKBOX FOR RATIONAL CONSTRAINT -->
                <div class="flex items-center space-x-3 mt-2 mb-4">
                    <input type="checkbox" id="rational_lock"
                        class="h-5 w-5 rounded text-blue-500 border-gray-600 focus:ring-blue-500 bg-slate-800">
                    <label for="rational_lock" class="text-white text-base font-medium select-none">Closed Curve
                        Constraint (Rational C₁/C₂)</label>
                </div>
                <!-- END CHECKBOX -->

                <div id="Duration_container" class="flex items-center space-x-3 mt-2"></div>
                <div id="Samples_container" class="flex items-center space-x-3 mt-2"></div>
            </div>

            <div class="param-group">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-xl font-semibold text-white">Export Code</h3>
                    <button id="copy_code_button"
                        class="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded-md text-sm font-medium transition-all shadow-lg text-white">
                        Copy Snippet
                    </button>
                </div>
                <p class="text-sm text-gray-400 mb-2">
                    Geometry function ready for <span class="font-mono text-indigo-300">three.js</span>:
                    <span id="copy_code_prompt"
                        class="ml-2 text-sm text-gray-500 transition-colors duration-300"></span>
                </p>
                <pre class="bg-slate-900 p-4 rounded-lg border border-slate-700 overflow-x-auto cursor-pointer"
                    id="code_pre_block"><code id="lissajous_code_output" class="font-mono text-sm text-slate-300 whitespace-pre"></code></pre>
            </div>
        </div>

        <p class="text-xs text-gray-400 mt-4 text-center">Use mouse/trackpad to orbit the camera.</p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Utility to get CSS variable color and convert to numeric hex
        const getCssColor = (name) => {
            const hex = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
            return parseInt(hex.startsWith('#') ? hex.substring(1) : hex, 16);
        };

        const SLATE_900 = getCssColor('--slate-900');

        // --- Configuration and State ---
        const config = {
            C1: { min: 1, max: 100, step: 0.01, default: 12, scale: 100, label: "C₁" },
            C2: { min: 1, max: 100, step: 0.01, default: 5, scale: 100, label: "C₂" },
            A: { min: 0, max: (2 * Math.PI), step: (2 * Math.PI) / 1000, default: 0, scale: 1000 / (2 * Math.PI), label: "A (rad)" },
            Duration: { min: 0, max: (8 * Math.PI), step: (2 * Math.PI) / 500, default: 2 * Math.PI, scale: 1000 / (2 * Math.PI), label: "Domain" },
            // FIX: Added scale: 1 to Samples to prevent NaN in slider initialization
            Samples: { min: 200, max: 10000, step: 1, default: 4000, scale: 1, label: "Samples" }
        };

        const state = {
            C1: config.C1.default,
            C2: config.C2.default,
            A: config.A.default,
            Duration: config.Duration.default,
            Samples: config.Samples.default,
            isRationalLocked: false // NEW: State for the constraint lock
        };

        let scene, camera, renderer, controls, line;

        // --- Lissajous Function ---
        const lissajous = (t, m1, m2, a) => {
            const phase = a;
            const x = Math.sin(m2 * t) * Math.cos(m1 * t - phase);
            const y = Math.cos(m2 * t);
            const z = Math.sin(m2 * t) * Math.sin(m1 * t - phase);
            return new THREE.Vector3(x, y, z);
        };

        // --- Window Resize Handler ---
        const onWindowResize = () => {
            if (!renderer) return;

            const container = document.getElementById('canvasContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        };

        // --- THREE.js Setup ---
        const initThree = () => {
            const container = document.getElementById('canvasContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(SLATE_900);

            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            // ADJUSTMENT: Move the camera closer to make the visualization fill the space
            camera.position.set(1.5, 1.5, 3);

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('threeCanvas'),
                antialias: true
            });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 2;
            controls.maxDistance = 10;
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Reference Sphere (Unit Sphere)
            const geometry = new THREE.SphereGeometry(1.0, 64, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0x334155,
                wireframe: true,
                transparent: true,
                opacity: 0.2
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.renderOrder = 0;
            scene.add(sphere);

            regenerateCurve();
            animate();
        };

        const regenerateCurve = () => {
            if (line) {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            }

            const points = [];
            const segments = parseInt(state.Samples);
            const domain = state.Duration;

            for (let i = 0; i <= segments; i++) {
                const t = (i / segments) * domain;
                const point = lissajous(t, state.C1, state.C2, state.A);
                points.push(point);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x818cf8,
                linewidth: 2,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                depthTest: false // Always on top effect
            });
            line = new THREE.Line(geometry, material);
            line.renderOrder = 1;
            scene.add(line);
        };

        const animate = () => {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        };

        // --- RATIONAL CONSTRAINT LOGIC ---

        /**
         * Finds the simplest rational approximation (M/N) for a given value (ratio).
         * @param {number} value The ratio to approximate (e.g., C1/C2).
         * @param {number} maxDenominator Maximum value for the numerator/denominator.
         * @returns {{ M: number, N: number }} The best simple rational ratio.
         */
        const findBestRationalRatio = (value, maxDenominator = 8) => {
            if (value === 0) return { M: 1, N: 1 };

            let bestM = 1;
            let bestN = 1;
            let minDiff = Infinity;

            // Check ratios M/N where M and N are between 1 and maxDenominator
            for (let N = 1; N <= maxDenominator; N++) {
                for (let M = 1; M <= maxDenominator; M++) {
                    const ratio = M / N;
                    const diff = Math.abs(value - ratio);

                    // Prefer closer approximation, but also prefer smaller ratios
                    if (diff < minDiff || (diff === minDiff && (M + N) < (bestM + bestN))) {
                        minDiff = diff;
                        bestM = M;
                        bestN = N;
                    }
                }
            }
            return { M: bestM, N: bestN };
        };

        /**
         * Snaps the active frequency (C1 or C2) to maintain a simple rational ratio with the passive frequency.
         * @param {string} activeId 'C1' or 'C2'.
         * @param {number} rawNewValue The raw slider value from the input event.
         */
        const snapFrequencies = (activeId, rawNewValue) => {
            if (!state.isRationalLocked) return;

            const passiveId = activeId === 'C1' ? 'C2' : 'C1';
            const passiveC = state[passiveId];

            // 1. Convert the raw value from the slider input event back to the real float value
            const activeConfig = config[activeId];
            const newActiveC_Raw = rawNewValue / activeConfig.scale;

            // 2. Find the closest rational ratio to the *intended* new value
            // We find M/N such that M/N ≈ activeC / passiveC (e.g., C₁/C₂)
            const targetRatio = newActiveC_Raw / passiveC;
            const { M, N } = findBestRationalRatio(targetRatio);

            // 3. Calculate the snapped value: New Active C = Passive C * (M / N)
            const newActiveC_Snapped = passiveC * (M / N);

            // 4. Update the actual state
            state[activeId] = newActiveC_Snapped;

            // 5. Update the slider UI (force the thumb to jump to the snapped position)
            const slider = document.getElementById(`${activeId}_slider`);
            const valueSpan = document.getElementById(`${activeId}_value`);

            if (slider && valueSpan) {
                // Round the snapped value for setting the slider UI element
                const roundedValue = Math.round(newActiveC_Snapped * activeConfig.scale);
                slider.value = roundedValue;

                // Determine decimals for display (2 for C1/C2)
                valueSpan.textContent = newActiveC_Snapped.toFixed(2);
            }

            // --- FIX: CALCULATE AND SET THE CORRECT DOMAIN ---
            // The domain T required to close the loop is T = (2π * N) / C₂ or T = (2π * M) / C₁
            // Here, passiveC = C₂ and N is the denominator for the ratio C₁/C₂
            // If the active slider was C₂, then passiveC = C₁ and we'd use (2π * M) / C₁
            let newDomain;
            if (activeId === 'C1') {
                // Ratio was C₁/C₂ ≈ M/N. T = (2π * N) / C₂
                newDomain = (2 * Math.PI * N) / passiveC; // passiveC = C₂
            } else {
                // Active was C₂. Ratio was C₂/C₁ ≈ M/N. T = (2π * N) / C₁
                newDomain = (2 * Math.PI * N) / passiveC; // passiveC = C₁
                // Note: findBestRationalRatio always gives M/N for (active/passive).
                // If active=C₂, targetRatio=C₂/C₁. We get M/N ≈ C₂/C₁.
                // T = (2π * M) / C₂ or T = (2π * N) / C₁.
                // newDomain = (2 * Math.PI * N) / passiveC; (This is correct)
            }

            state.Duration = newDomain;

            // Update the Domain slider UI to reflect the new calculated domain
            const durationSlider = document.getElementById('Duration_slider');
            const durationValueSpan = document.getElementById('Duration_value');
            const durationConfig = config.Duration;

            if (durationSlider && durationValueSpan) {
                const scaledDomain = Math.round(newDomain * durationConfig.scale);
                // Clamp value to slider min/max in case of extreme ratios
                const clampedScaledDomain = Math.max(
                    Math.round(durationConfig.min * durationConfig.scale),
                    Math.min(Math.round(durationConfig.max * durationConfig.scale), scaledDomain)
                );

                durationSlider.value = clampedScaledDomain;

                // Also update state.Duration if we clamped
                if (scaledDomain !== clampedScaledDomain) {
                    state.Duration = clampedScaledDomain / durationConfig.scale;
                    durationValueSpan.textContent = state.Duration.toFixed(3);
                } else {
                    durationValueSpan.textContent = newDomain.toFixed(3);
                }
            }
            // --- END FIX ---

            // 6. Re-render the curve and update the code snippet
            regenerateCurve();
            updateCodeSnippet();
        };

        // --- End RATIONAL CONSTRAINT LOGIC ---

        // --- Copy to Clipboard Helper ---
        function copyToClipboard(text, feedbackElement, originalMessage = "") {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = 0;
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();

            let success = false;
            try {
                success = document.execCommand('copy');
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }

            document.body.removeChild(textarea);

            if (success && feedbackElement) {
                feedbackElement.textContent = "Copied!";
                feedbackElement.classList.remove('text-gray-500');
                feedbackElement.classList.add('text-green-400');

                setTimeout(() => {
                    feedbackElement.textContent = originalMessage;
                    feedbackElement.classList.remove('text-green-400');
                    if (originalMessage) {
                        feedbackElement.classList.add('text-gray-500');
                    }
                }, 1500);
            }
        }

        // --- Code Snippet Updater ---
        const updateCodeSnippet = () => {
            const codeOutput = document.getElementById('lissajous_code_output');
            if (!codeOutput) return;

            // Helper to format floats to a clean string representation (e.g., 3.000 -> 3)
            const f = (n, fixed = 3) => {
                const s = n.toFixed(fixed);
                // Remove trailing zeros and decimal point if they exist
                return s.replace(/\.?0+$/, "");
            };

            // Format to match the requested simple lambda: (t) => lissajous(C1, C2, A, t)
            const c1Str = f(state.C1, 2);
            const c2Str = f(state.C2, 2);
            const aStr = f(state.A, 3);

            // --- NEW: Format the domain string ---
            const domain = state.Duration;
            let domainStr = "";
            const twoPi = 2 * Math.PI;
            // Check for multiples of 2*PI within a small tolerance
            const multiple = domain / twoPi;

            if (Math.abs(multiple - Math.round(multiple)) < 0.001 && Math.round(multiple) > 0) {
                const N = Math.round(multiple);
                domainStr = (N === 1) ? "2 * Math.PI" : `${N} * 2 * Math.PI`;
            } else {
                domainStr = f(domain, 3); // Use the formatted float value
            }
            // --- END NEW ---

            // WRAP in square brackets as requested
            const snippet = `[(t) => lissajous(${c1Str}, ${c2Str}, ${aStr}, t), ${domainStr}]`;
            codeOutput.textContent = snippet;
        };

        // --- UI Setup ---

        const createSlider = (id, params) => {
            const container = document.getElementById(`${id}_container`);
            if (!container) return;

            const sliderId = `${id}_slider`;
            const valueSpanId = `${id}_value`;

            // Determine number of decimal places for display
            let decimals = 0;
            if (id === 'A' || id === 'Duration') {
                decimals = 3;
            } else {
                decimals = 2; // C1 and C2 always use 2 decimals for display
            }

            const scale = params.scale || 1; // Robustly define scale here (though fixed in config now)

            const initialValue = params.default * scale;
            const displayInitialValue = params.default;

            container.innerHTML = `
                <span class="w-20 text-center font-bold text-white text-lg">${params.label}:</span>
                <input type="range" id="${sliderId}"
                    min="${Math.round(params.min * scale)}"
                    max="${Math.round(params.max * scale)}"
                    step="${Math.round(params.step * scale)}"
                    value="${Math.round(initialValue)}"
                    class="flex-grow">
                <span id="${valueSpanId}" class="slider-label w-24 text-right">
                    ${(displayInitialValue).toFixed(decimals)}
                </span>
            `;

            const slider = document.getElementById(sliderId);
            const valueSpan = document.getElementById(valueSpanId);

            slider.addEventListener('input', () => {
                const rawValue = parseFloat(slider.value);
                let newValue = rawValue / scale;

                // 1. Update state based on input value first
                state[id] = id === 'Samples' ? Math.round(newValue) : newValue;

                if ((id === 'C1' || id === 'C2') && state.isRationalLocked) {
                    // 2. Call snapping logic, which will recalculate state[id], update UI (slider/span), and re-render
                    snapFrequencies(id, rawValue);
                } else {
                    // 3. For unlocked controls, update UI and re-render normally
                    // FIX: Ensure Samples is always displayed as a whole number
                    valueSpan.textContent = id === 'Samples' ? Math.round(state[id]).toFixed(0) : state[id].toFixed(decimals);
                    regenerateCurve();
                    updateCodeSnippet();
                }
            });
        };

        // --- Initialization ---
        const init = () => {
            // Setup sliders first
            Object.keys(config).forEach(id => {
                createSlider(id, config[id]);
            });

            // Set up the Rational Lock Checkbox
            const rationalLockCheckbox = document.getElementById('rational_lock');
            if (rationalLockCheckbox) {
                rationalLockCheckbox.addEventListener('change', (e) => {
                    state.isRationalLocked = e.target.checked;

                    const durationSlider = document.getElementById('Duration_slider');
                    const durationContainer = document.getElementById('Duration_container');

                    if (state.isRationalLocked) {

                        // --- 1. Disable Domain Slider ---
                        // The domain will be *calculated* by snapFrequencies, not just set to 2π
                        durationSlider.disabled = true;
                        durationContainer.classList.add('opacity-50');

                        // --- 2. Snap Frequencies (which will also set the correct domain) ---
                        // Use C1's current value as the starting point for snapping
                        snapFrequencies('C1', parseFloat(document.getElementById('C1_slider').value));

                    } else {
                        // Re-enable the slider and remove visual dimming
                        durationSlider.disabled = false;
                        durationContainer.classList.remove('opacity-50');

                        // Re-render, just in case
                        regenerateCurve();
                        updateCodeSnippet();
                    }
                });
            }


            // Initialize Copy Button logic
            const copyButton = document.getElementById('copy_code_button');
            const codeOutput = document.getElementById('lissajous_code_output');
            const prompt = document.getElementById('copy_code_prompt');
            const preBlock = document.getElementById('code_pre_block');

            if (copyButton && codeOutput) {
                const handleCopy = () => {
                    copyToClipboard(codeOutput.textContent, prompt, "");
                };

                copyButton.addEventListener('click', handleCopy);
                preBlock.addEventListener('click', handleCopy);
            }

            updateCodeSnippet();
            initThree();
        };

        // Attach resize listener
        window.addEventListener('resize', onWindowResize);

        // Start everything when the window is fully loaded
        window.onload = init;

    </script>
</body>

</html>