<!DOCTYPE html>
<!--
 Required Notice: Copyright 2025 Gabriel Levy. All rights reserved.
 Licensed under the Polyform Noncommercial License 1.0.0
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solids Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "dat-gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js",
                "gui": "../gui.js",
                "solids": "../solids.js",
                "geometry": "../geometry.js"
            }
        }
    </script>
    <style>
        :root {
            --slate-900: #0f172a;
            --slate-800: #1e293b;
            --slate-700: #334155;
            --blue-500: #3b82f6;
            --indigo-400: #818cf8;
            --sidebar-width: 224px;
            --footer-height: calc((100vw - 474px) * 0.22);
            --right-sidebar-width: 250px;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--slate-900);
            color: #E2E8F0;
            overflow: hidden;
            margin: 0;
            display: flex;
        }

        #sidebar {
            width: var(--sidebar-width);
            flex-shrink: 0;
            height: 100vh;
            background-color: rgba(15, 23, 42, 0.95);
            border-right: 1px solid var(--slate-700);
            display: flex;
            flex-direction: column;
            z-index: 20;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #main {
            flex: 1;
            min-width: 0;
            position: relative;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(to bottom, #0f172a, #1e293b);
            min-height: 0;
            /* Allow shrinking */
            overflow: hidden;
        }

        #footer {
            height: var(--footer-height);
            background-color: rgba(15, 23, 42, 0.95);
            border-top: 1px solid var(--slate-700);
            display: grid;
            grid-template-rows: repeat(2, 1fr);
            grid-auto-flow: column;
            align-items: center;
            overflow-x: auto;
            padding: calc((100vw - 474px) * 0.008);
            gap: calc((100vw - 474px) * 0.008);
            backdrop-filter: blur(10px);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        /* Scrollbar styling for footer */
        #footer::-webkit-scrollbar {
            height: 8px;
        }

        #footer::-webkit-scrollbar-track {
            background: var(--slate-900);
        }

        #footer::-webkit-scrollbar-thumb {
            background: var(--slate-700);
            border-radius: 4px;
        }

        #footer::-webkit-scrollbar-thumb:hover {
            background: var(--slate-600);
        }

        .thumb-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: calc((100vw - 474px) * 0.09);
            height: 100%;
            background-color: var(--slate-800);
            border: 2px solid var(--slate-700);
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            padding: calc((100vw - 474px) * 0.005);
            position: relative;
        }

        .thumb-btn:hover {
            border-color: var(--blue-500);
            background-color: var(--slate-700);
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
        }

        .thumb-btn.active {
            border-color: var(--blue-500);
            background-color: rgba(59, 130, 246, 0.15);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .thumb-btn img {
            width: calc((100vw - 474px) * 0.06);
            height: calc((100vw - 474px) * 0.06);
            object-fit: contain;
            margin-bottom: calc((100vw - 474px) * 0.004);
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));
        }

        .thumb-btn span {
            font-size: calc((100vw - 474px) * 0.008);
            text-align: center;
            line-height: 1.1;
            color: #cbd5e1;
        }

        #code-panel {
            position: absolute;
            bottom: var(--footer-height);
            /* Sit above footer */
            left: 0;
            right: 0;
            height: 200px;
            background-color: var(--slate-800);
            border-top: 1px solid var(--slate-700);
            padding: 1rem;
            transform: translateY(150%);
            /* Hide fully */
            transition: transform 0.3s ease;
            z-index: 30;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        #code-panel.open {
            transform: translateY(0);
        }

        textarea {
            font-family: 'JetBrains Mono', monospace;
            background-color: var(--slate-900);
            color: #a5b4fc;
            border: 1px solid var(--slate-700);
            resize: none;
            font-size: 0.8rem;
        }

        .btn {
            padding: 0.4rem 0.6rem;
            border-radius: 0.25rem;
            font-weight: 500;
            font-size: 0.875rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .btn-primary {
            background-color: var(--blue-500);
            color: white;
        }

        .btn-primary:hover {
            background-color: #2563eb;
        }

        .btn-secondary {
            background-color: var(--slate-700);
            color: white;
        }

        .btn-secondary:hover {
            background-color: var(--slate-600);
        }

        .op-item {
            background-color: var(--slate-800);
            border: 1px solid var(--slate-700);
            padding: 0.4rem;
            margin-bottom: 0.4rem;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1), border-color 0.2s, opacity 0.2s;
            user-select: none;
        }

        .op-item:hover {
            border-color: var(--indigo-400);
        }

        .op-item.dragging {
            opacity: 0.2;
            transform: scale(0.98);
            border-style: dashed;
            z-index: 10;
        }

        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1rem;
            height: 1.5rem;
            margin-right: 0.25rem;
            color: var(--slate-500);
            flex-shrink: 0;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .op-item:hover .drag-handle {
            opacity: 1;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-handle svg {
            width: 0.8rem;
            height: 0.8rem;
            fill: currentColor;
        }

        #saveBtn {
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            background-color: rgba(15, 23, 42, 0.8);
            border: 2px solid var(--slate-700);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
        }

        #save-actions {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            z-index: 40;
        }

        #meshStats {
            background-color: rgba(15, 23, 42, 0.8);
            border: 1px solid var(--slate-700);
            border-radius: 0.5rem;
            padding: 0.4rem 0.8rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: rgba(165, 180, 252, 0.8);
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            white-space: nowrap;
        }

        #saveBtn:hover {
            border-color: var(--blue-500);
            transform: scale(1.1);
        }

        #saveBtn svg {
            width: 1.5rem;
            height: 1.5rem;
            stroke: #fbbf24;
            fill: none;
            stroke-width: 2;
        }

        #right-sidebar {
            width: var(--right-sidebar-width);
            flex-shrink: 0;
            height: 100vh;
            background-color: rgba(15, 23, 42, 0.95);
            border-left: 1px solid var(--slate-700);
            display: flex;
            flex-direction: column;
            z-index: 20;
            overflow-y: auto;
            padding: 1rem;
        }

        .saved-item {
            background-color: var(--slate-800);
            border: 1px solid var(--slate-700);
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .saved-item:hover {
            border-color: var(--blue-500);
            transform: translateY(-2px);
        }

        .saved-item img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
            background-color: #000;
        }

        .saved-item .title {
            font-size: 0.8rem;
            font-weight: 500;
            color: #cbd5e1;
            margin-bottom: 0.1rem;
        }

        .saved-item .details {
            font-size: 0.7rem;
            color: #94a3b8;
            margin-bottom: 0.5rem;
        }

        .saved-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.4rem;
            margin-top: 0.4rem;
        }

        .action-btn {
            font-size: 0.65rem;
            padding: 0.2rem 0.4rem;
            border-radius: 0.2rem;
            background-color: var(--slate-700);
            color: #cbd5e1;
            border: 1px solid var(--slate-600);
            transition: all 0.2s;
            font-weight: 600;
        }

        .action-btn:hover {
            background-color: var(--blue-500);
            color: white;
            border-color: var(--blue-400);
        }

        .del-btn:hover {
            background-color: #ef4444;
            border-color: #f87171;
        }
    </style>
</head>

<body>

    <div id="sidebar" class="p-4 space-y-6">
        <div>
            <h1 class="text-xl font-bold text-white mb-1">Solids Generator</h1>
            <p class="text-xs text-indigo-300">Conway Mesh Operators</p>
        </div>

        <!-- Base Solid Display -->
        <div id="baseSolidDisplay" class="space-y-2">
            <label class="text-xs uppercase font-semibold text-slate-400">Source Solid</label>
            <div class="bg-slate-800/50 border border-slate-700 rounded-lg p-3 flex items-center space-x-3">
                <img id="baseThumb" src=""
                    class="w-12 h-12 object-contain bg-slate-900 rounded-md border border-slate-700 shadow-sm" />
                <div class="flex flex-col min-w-0">
                    <div id="baseTitle" class="text-xs font-black text-white uppercase tracking-wider line-clamp-2">
                    </div>
                    <span id="baseStats"
                        class="text-[0.6rem] text-indigo-300/60 font-medium uppercase tracking-tight"></span>
                </div>
            </div>
        </div>

        <!-- Operations Queue -->
        <div class="space-y-2 flex-1 overflow-hidden flex flex-col">
            <div class="flex items-center justify-between">
                <label class="text-xs uppercase font-semibold text-slate-400">Operations</label>
                <button onclick="resetOps()"
                    class="text-[0.65rem] text-red-400 hover:text-red-300 uppercase font-bold tracking-wider">Clear
                    All</button>
            </div>
            <div id="opsList" class="relative flex-1 overflow-y-auto space-y-2 pr-2">
                <!-- Operations go here -->
            </div>

            <label class="text-xs uppercase font-semibold text-slate-400 mt-4">Add Operation</label>
            <div class="grid grid-cols-2 gap-2 pt-1">
                <button onclick="addOp('kis')" class="btn btn-secondary text-[0.65rem]">Kis</button>
                <button onclick="addOp('ambo')" class="btn btn-secondary text-[0.65rem]">Ambo</button>
                <button onclick="addOp('gyro')" class="btn btn-secondary text-[0.65rem]">Gyro</button>
                <button onclick="addOp('snub')" class="btn btn-secondary text-[0.65rem]">Snub</button>
                <button onclick="addOp('dual')" class="btn btn-secondary text-[0.65rem]">Dual</button>
                <button onclick="addOp('truncate')" class="btn btn-secondary text-[0.65rem]">Truncate</button>
                <button onclick="addOp('hankin')" class="btn btn-secondary text-[0.65rem]">Hankin</button>
            </div>
        </div>

        <!-- Visualization Options -->
        <div class="space-y-2 border-t border-slate-700 pt-4">
            <label class="text-xs uppercase font-semibold text-slate-400">Visualization</label>
            <div class="flex items-center justify-between">
                <span class="text-sm">Geodesic Edges</span>
                <button id="toggleGeo"
                    class="w-10 h-5 rounded-full bg-slate-700 relative transition-colors focus:outline-none">
                    <div class="w-3 h-3 bg-white rounded-full absolute top-1 left-1 transition-transform"></div>
                </button>
            </div>
            <div class="flex items-center justify-between mt-2">
                <span class="text-sm">Show Faces</span>
                <button id="toggleFaces"
                    class="w-10 h-5 rounded-full bg-blue-500 relative transition-colors focus:outline-none">
                    <div
                        class="w-3 h-3 bg-white rounded-full absolute top-1 left-1 transform translate-x-5 transition-transform">
                    </div>
                </button>
            </div>
            <div class="flex items-center justify-between mt-2">
                <span class="text-sm">Show Vertices</span>
                <button id="toggleVerts"
                    class="w-10 h-5 rounded-full bg-blue-500 relative transition-colors focus:outline-none">
                    <div
                        class="w-3 h-3 bg-white rounded-full absolute top-1 left-1 transform translate-x-5 transition-transform">
                    </div>
                </button>
            </div>
        </div>

        <!-- Export Removed -->
        <div class="pt-2 text-xs text-slate-500 italic text-center">
            Configure solid then click star to save
        </div>
    </div>

    <div id="main">
        <div id="canvas-container">
            <div id="save-actions">
                <div id="meshStats"></div>
                <button id="saveBtn" title="Save to Collection">
                    <!-- Star Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                        stroke-linejoin="round">
                        <polygon
                            points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2">
                        </polygon>
                    </svg>
                </button>
            </div>
            <canvas id="canvas" class="w-full h-full block"></canvas>
        </div>

        <div id="footer">
            <!-- Dynamic Thumbnails -->
        </div>
    </div>

    <div id="right-sidebar">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-lg font-bold text-white">Saved Solids</h2>
            <button onclick="clearSavedSolids()"
                class="text-xs text-red-400 hover:text-red-300 uppercase font-bold tracking-wider">Clear All</button>
        </div>
        <div id="savedList" class="flex-1 overflow-y-auto">
            <!-- Saved items go here -->
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Solids } from 'solids';
        import { MeshOps } from 'geometry';

        // --- STATE ---
        const state = {
            base: 'icosahedron',
            ops: [], // Array of objects { op: string, params: object }
            showGeodesics: true,
            showFaces: true,
            showVertices: false
        };

        const baseThumbnails = {};
        // Make draggingIndex global so inline handlers can see it if needed, mainly strictly module scope is fine for listeners but good for debug
        let draggingIndex = -1;

        const OP_DEFS = {
            kis: { label: 'Kis', params: {} },
            ambo: { label: 'Ambo', params: {} },
            gyro: { label: 'Gyro', params: {} },
            snub: { label: 'Snub', params: {} },
            dual: { label: 'Dual', params: {} },
            truncate: { label: 'Truncate', params: { t: { val: 0.25, min: 0.01, max: 0.5, step: 0.01 } } },
            hankin: { label: 'Hankin', params: { angle: { val: 0.0, min: 0.0, max: 0.5, step: 0.01 } } }
        };

        let scene, camera, renderer, controls;
        let mainMesh, edgeLines, vertPoints;

        // --- MAIN ---

        function init() {
            // Initialize Three.js
            const canvas = document.getElementById('canvas');
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a); // slate-900

            // New Camera Position: Closer to fill viewport
            // Unit sphere radius = 1.0. At z=2.0, FOV=45 deg covers approx height = 2 * tan(22.5) * 2 = 1.65.
            // Sphere diam = 2.0. So 2.0 is slightly cropped? No, tan(22.5) ~ 0.41. 
            // Visible height at z=2 is 2*2*0.41 = 1.65. Sphere is 2.0. So it crops.
            // Let's try z=2.8. 2.8 * 0.82 = 2.3. Fits.
            // Previous was (2,2,4) -> dist 4.9.
            // Setting position to (0,0,2.8) looks straight on.
            // Setting position to (1.5, 1.5, 1.5) -> dist ~2.6.

            camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            camera.position.set(2, 1.5, 2); // Nice angle, closer

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true; // Slowly rotate for effect?
            controls.autoRotateSpeed = 2.0;

            // Lights
            const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // Secondary Light for drama
            const rimLight = new THREE.SpotLight(0x3b82f6, 5);
            rimLight.position.set(-5, 0, -5);
            scene.add(rimLight);

            // Events
            window.addEventListener('resize', onResize);

            // Toggles
            document.getElementById('toggleGeo').parentElement.addEventListener('click', () => {
                state.showGeodesics = !state.showGeodesics;
                updateToggles();
                update();
            });
            document.getElementById('toggleFaces').parentElement.addEventListener('click', () => {
                state.showFaces = !state.showFaces;
                updateToggles();
                update();
            });
            document.getElementById('toggleVerts').parentElement.addEventListener('click', () => {
                state.showVertices = !state.showVertices;
                updateToggles();
                update();
            });

            document.getElementById('saveBtn').addEventListener('click', saveSolid);

            // Generate Thumbnails
            generateThumbnails();

            updateToggles();
            onResize();
            update();
            renderBaseSolid();
            animate();
        }

        async function generateThumbnails() {
            const footer = document.getElementById('footer');
            const thumbKeys = Object.keys(Solids).filter(k => typeof Solids[k] === 'function' && k !== 'normalize');

            // Create offscreen renderer
            const width = 256; // High-res for larger thumbs
            const height = 256;
            const offRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            offRenderer.setSize(width, height);
            offRenderer.setClearColor(0x000000, 0); // Transparent

            const offScene = new THREE.Scene();
            const offCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 10);
            offCamera.position.set(1.5, 1.5, 1.5);
            offCamera.lookAt(0, 0, 0);

            const light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.set(2, 5, 3);
            offScene.add(light);
            offScene.add(new THREE.AmbientLight(0xffffff, 0.5));

            // Material for thumbnails
            const mat = new THREE.MeshPhongMaterial({
                color: 0x3b82f6,
                flatShading: true,
                shininess: 30
            });
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });

            for (const key of thumbKeys) {
                // Clear scene
                while (offScene.children.length > 0) {
                    const obj = offScene.children[0];
                    if (obj.isLight) { // Keep lighting? adjust
                        // Actually, better to remove meshes.
                        if (obj.isMesh || obj.isLineSegments) offScene.remove(obj);
                        else break; // light is at end? No.
                    }
                    if (obj.isLight) {
                        // Keep light
                        offScene.children.push(offScene.children.shift()); // Cycle
                        if (offScene.children[0].isLight && offScene.children.length <= 2) break; // Assuming 2 lights
                    } else {
                        offScene.remove(obj);
                    }
                }

                // Re-add lights if cleared (simpler to just clear all and re-add)
                offScene.clear();
                offScene.add(light);
                offScene.add(new THREE.AmbientLight(0xffffff, 0.5));

                const meshData = Solids[key]();
                // Triangulate
                const vertices = [];
                meshData.faces.forEach(f => {
                    for (let i = 1; i < f.length - 1; i++) {
                        vertices.push(...meshData.vertices[f[0]].toArray());
                        vertices.push(...meshData.vertices[f[i]].toArray());
                        vertices.push(...meshData.vertices[f[i + 1]].toArray());
                    }
                });
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geo.computeVertexNormals();

                const mesh = new THREE.Mesh(geo, mat);
                offScene.add(mesh);

                // Edges (optional, but looks nice)
                const edgeIndices = new Set();
                meshData.faces.forEach(f => {
                    for (let i = 0; i < f.length; i++) {
                        const a = f[i];
                        const b = f[(i + 1) % f.length];
                        const k = a < b ? `${a}_${b}` : `${b}_${a}`;
                        if (!edgeIndices.has(k)) edgeIndices.add(k);
                    }
                });
                const linePoints = [];
                edgeIndices.forEach(k => {
                    const [ai, bi] = k.split('_').map(Number);
                    linePoints.push(meshData.vertices[ai], meshData.vertices[bi]);
                });
                const lineGeo = new THREE.BufferGeometry().setFromPoints(linePoints);
                const lines = new THREE.LineSegments(lineGeo, lineMat);
                offScene.add(lines);

                // Render
                offRenderer.render(offScene, offCamera);

                // Create Button
                const btn = document.createElement('div');
                btn.className = `thumb-btn ${state.base === key ? 'active' : ''}`;
                btn.onclick = () => {
                    state.base = key;
                    update();
                    renderBaseSolid();
                    // Update active state
                    document.querySelectorAll('.thumb-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    // auto reset ops?
                    // resetOps(); // Maybe nicer to keep ops applied?
                };

                const img = document.createElement('img');
                const dataURL = offRenderer.domElement.toDataURL();
                img.src = dataURL;
                baseThumbnails[key] = dataURL;

                const span = document.createElement('span');
                // Format Name: truncatedIcosahedron -> Truncated Icosahedron -> Truncated\nIcosahedron?
                // Split camel case
                const title = key.replace(/([A-Z])/g, ' $1').trim();
                const parts = title.split(' ');
                span.innerHTML = parts.join('<br>');

                btn.appendChild(img);
                btn.appendChild(span);
                footer.appendChild(btn);
            }

            // Cleanup
            offRenderer.dispose();
        }

        function updateToggles() {
            const tG = document.getElementById('toggleGeo');
            const tF = document.getElementById('toggleFaces');
            const tV = document.getElementById('toggleVerts');

            tG.className = `w-10 h-5 rounded-full relative transition-colors focus:outline-none ${state.showGeodesics ? 'bg-blue-500' : 'bg-slate-700'}`;
            tG.children[0].className = `w-3 h-3 bg-white rounded-full absolute top-1 left-1 transition-transform ${state.showGeodesics ? 'translate-x-5' : ''}`;

            tF.className = `w-10 h-5 rounded-full relative transition-colors focus:outline-none ${state.showFaces ? 'bg-blue-500' : 'bg-slate-700'}`;
            tF.children[0].className = `w-3 h-3 bg-white rounded-full absolute top-1 left-1 transition-transform ${state.showFaces ? 'translate-x-5' : ''}`;

            tV.className = `w-10 h-5 rounded-full relative transition-colors focus:outline-none ${state.showVertices ? 'bg-blue-500' : 'bg-slate-700'}`;
            tV.children[0].className = `w-3 h-3 bg-white rounded-full absolute top-1 left-1 transition-transform ${state.showVertices ? 'translate-x-5' : ''}`;
        }

        function onResize() {
            const sidebar = document.getElementById('sidebar');
            const rightSidebar = document.getElementById('right-sidebar');
            const container = document.getElementById('canvas-container');

            // Explicitly calculate available width
            const sidebarWidth = sidebar.getBoundingClientRect().width;
            const rightWidth = rightSidebar.getBoundingClientRect().width;
            const w = window.innerWidth - sidebarWidth - rightWidth;
            const h = container.clientHeight;

            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            camera.updateProjectionMatrix();
        }

        // --- SAVED ITEMS ---
        const savedSolids = [];

        function saveSolid() {
            // Capture thumbnail
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');

            const title = state.base.replace(/([A-Z])/g, ' $1').trim();

            // Get current counts from window.currentMesh
            const vCount = window.currentMesh.vertices.length;
            const fCount = window.currentMesh.faces.length;
            const eCount = window.currentMesh.edgeCount || 0;

            // Generate summary
            const opsSummary = state.ops.map(o => {
                if (o.op === 'truncate') return `Tr(${o.params.t})`;
                if (o.op === 'hankin') return `Hk(${o.params.angle.toFixed(2)})`;
                return o.op.charAt(0).toUpperCase() + o.op.slice(1);
            }).join(', ') || 'Base Solid';

            const item = {
                id: Date.now(),
                base: state.base,
                ops: JSON.parse(JSON.stringify(state.ops)), // Deep copy
                geodesics: state.showGeodesics,
                faces: state.showFaces,
                vertices: state.showVertices,
                thumb: dataURL,
                title: title,
                desc: opsSummary,
                stats: `${vCount}V ${eCount}E ${fCount}F`
            };

            savedSolids.push(item);
            renderSavedList();
        }

        function renderSavedList() {
            const list = document.getElementById('savedList');
            list.innerHTML = '';

            savedSolids.forEach((item, index) => {
                const el = document.createElement('div');
                el.className = 'saved-item';
                el.innerHTML = `
                    <img src="${item.thumb}" alt="${item.title}" />
                    <div class="flex justify-between items-start">
                        <div class="title capitalize">${item.title}</div>
                        <div class="text-[0.55rem] font-mono text-indigo-400 opacity-60">${item.stats}</div>
                    </div>
                    <div class="details uppercase opacity-70">${item.desc}</div>
                    <div class="saved-actions" onclick="event.stopPropagation()">
                        <button class="action-btn" onclick="copyCode(${index}, 'js')">JS</button>
                        <button class="action-btn" onclick="copyCode(${index}, 'cpp')">C++</button>
                        <button class="action-btn del-btn" onclick="deleteSolid(${index})">&times;</button>
                    </div>
                `;
                el.onclick = () => restoreSolid(item);
                list.insertBefore(el, list.firstChild); // Newest first
            });
        }

        window.deleteSolid = (index) => {
            savedSolids.splice(index, 1);
            renderSavedList();
        };

        window.copyCode = (index, lang) => {
            const item = savedSolids[index];
            // Reconstruct mesh to generate code
            let mesh = Solids[item.base]();
            mesh = MeshOps.clone(mesh);

            // Re-run pipeline with params
            item.ops.forEach(o => {
                const opName = typeof o === 'string' ? o : o.op; // helper for legacy
                if (opName === 'truncate') {
                    mesh = MeshOps.truncate(mesh, o.params.t);
                } else if (opName === 'hankin') {
                    mesh = MeshOps.hankin(mesh, o.params.angle);
                } else if (MeshOps[opName]) {
                    mesh = MeshOps[opName](mesh);
                }
            });

            let code = '';
            if (lang === 'cpp') {
                code = generateCPlusPlus(mesh);
            } else {
                code = generateJavascript(mesh);
            }

            navigator.clipboard.writeText(code).then(() => {
                console.log(`${lang.toUpperCase()} copied!`);
                // Visual feedback?
            });
        };

        function generateCPlusPlus(m) {
            let s = '// Generated Solid (C++)\n';
            s += `// V: ${m.vertices.length}, F: ${m.faces.length}\n\n`;
            s += 'const std::vector<Vector3> vertices = {\n';
            s += m.vertices.map((v, i) => `    Vector3(${v.x.toFixed(7)}, ${v.y.toFixed(7)}, ${v.z.toFixed(7)})${i < m.vertices.length - 1 ? ',' : ''}`).join('\n');
            s += '\n};\n\n';
            s += 'const std::vector<std::vector<int>> faces = {\n';
            s += m.faces.map((f, i) => `    {${f.join(', ')}}${i < m.faces.length - 1 ? ',' : ''}`).join('\n');
            s += '\n};\n';
            return s;
        }

        function generateJavascript(m) {
            let s = '// Generated Solid (JS)\n';
            s += `// V: ${m.vertices.length}, F: ${m.faces.length}\n\n`;
            s += 'const vertices = [\n';
            s += m.vertices.map((v, i) => `    new THREE.Vector3(${v.x.toFixed(7)}, ${v.y.toFixed(7)}, ${v.z.toFixed(7)})${i < m.vertices.length - 1 ? ',' : ''}`).join('\n');
            s += '\n];\n\n';
            s += 'const faces = [\n';
            s += m.faces.map((f, i) => `    [${f.join(', ')}]${i < m.faces.length - 1 ? ',' : ''}`).join('\n');
            s += '\n];\n';
            return s;
        }

        function restoreSolid(item) {
            state.base = item.base;
            state.ops = JSON.parse(JSON.stringify(item.ops));
            state.showGeodesics = item.geodesics;
            state.showFaces = item.faces !== undefined ? item.faces : true;
            state.showVertices = item.vertices;

            // Update UI
            updateToggles();
            renderOps();

            // Highlight active base in footer
            document.querySelectorAll('.thumb-btn').forEach(b => {
                if (b.classList.contains('active')) b.classList.remove('active');
                if (b.onclick.toString().includes(state.base)) b.classList.add('active');
            });

            update();
            renderBaseSolid();
        }

        function renderBaseSolid() {
            const thumb = baseThumbnails[state.base];
            const title = state.base.replace(/([A-Z])/g, ' $1').trim();
            const mesh = Solids[state.base]();

            document.getElementById('baseThumb').src = thumb || '';
            document.getElementById('baseTitle').innerText = title;
            document.getElementById('baseStats').innerText = `${mesh.vertices.length} Vertices â€¢ ${mesh.faces.length} Faces`;
        }

        window.enableDrag = (e) => {
            const item = e.target.closest('.op-item');
            if (item) item.draggable = true;
        };

        // Helper: Calculate insertion index based on static layout (ignoring transforms)
        function getDragTargetIndex(e, list) {
            const items = [...list.children];
            // Calculate mouse Y relative to the scrolling list container
            const listRect = list.getBoundingClientRect();
            const mouseY = e.clientY - listRect.top + list.scrollTop;

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                // mid point of the item in the list's coordinate space
                // offsetTop is correct because container is relative
                const mid = item.offsetTop + (item.offsetHeight / 2);
                if (mouseY < mid) {
                    return i;
                }
            }
            return items.length;
        }

        function renderOps() {
            const list = document.getElementById('opsList');
            // Clean up overrides if any
            list.innerHTML = '';

            // Container-level Drag Events
            list.ondragover = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                if (draggingIndex === -1) return;

                const targetIndex = getDragTargetIndex(e, list);
                const items = [...list.children];
                const draggingItem = items[draggingIndex];

                if (!draggingItem) return;

                // Amount to visual shift: height of item + gap (space-y-2 is 0.5rem = 8px)
                const shiftAmount = draggingItem.offsetHeight + 8;

                items.forEach((item, idx) => {
                    if (idx === draggingIndex) return;

                    item.style.transform = '';

                    // Transformation Logic
                    if (draggingIndex < targetIndex) {
                        // Dragging Down: items between draggingIndex and targetIndex shift UP
                        if (idx > draggingIndex && idx < targetIndex) {
                            item.style.transform = `translateY(-${shiftAmount}px)`;
                        }
                    } else {
                        // Dragging Up: items between targetIndex and draggingIndex shift DOWN
                        if (idx >= targetIndex && idx < draggingIndex) {
                            item.style.transform = `translateY(${shiftAmount}px)`;
                        }
                    }
                });
            };

            list.ondrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const fromIndex = draggingIndex;
                if (fromIndex === -1) return;

                const list = document.getElementById('opsList');
                let toIndex = getDragTargetIndex(e, list);

                // Adjust index: removing the item at fromIndex shifts subsequent indices down by 1
                if (fromIndex < toIndex) {
                    toIndex--;
                }

                if (fromIndex !== toIndex) {
                    const [movedItem] = state.ops.splice(fromIndex, 1);
                    state.ops.splice(toIndex, 0, movedItem);
                    update();
                }
                renderOps();
                draggingIndex = -1;
            };

            state.ops.forEach((o, i) => {
                const opDef = OP_DEFS[o.op];
                const el = document.createElement('div');
                el.className = 'op-item flex-col items-stretch text-sm text-indigo-300';
                el.draggable = false;

                // Item Drag Start/End
                el.addEventListener('dragstart', (e) => {
                    draggingIndex = i;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', i); // Required for Firefox
                    setTimeout(() => el.classList.add('dragging'), 0);
                });

                el.addEventListener('dragend', () => {
                    el.draggable = false;
                    el.classList.remove('dragging');
                    draggingIndex = -1;
                    if (list) {
                        [...list.children].forEach(c => c.style.transform = '');
                    }
                });

                let controlsHtml = '';
                if (opDef.params && Object.keys(opDef.params).length > 0) {
                    controlsHtml = '<div class="mt-2 space-y-2">';
                    Object.keys(opDef.params).forEach(key => {
                        const def = opDef.params[key];
                        const val = o.params[key];
                        controlsHtml += `
                            <div class="flex items-center text-[0.6rem] space-x-1" draggable="false">
                                <span class="w-12 text-slate-400 capitalize truncate">${key}</span>
                                <input type="range" 
                                    min="${def.min}" max="${def.max}" step="${def.step}" value="${val}"
                                    class="flex-1 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer min-w-0"
                                    oninput="updateOpParam(${i}, '${key}', this.value)"
                                    onmousedown="event.stopPropagation()"
                                />
                                <input type="number" step="${def.step}" value="${Number(val).toFixed(2)}"
                                    class="w-12 bg-transparent text-right font-mono text-slate-500 focus:outline-none focus:text-white [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                                    onchange="updateOpParam(${i}, '${key}', this.value)"
                                    onmousedown="event.stopPropagation()"
                                />
                                <span class="text-[0.5rem] text-slate-600 ml-0.5">${key === 'angle' ? 'rev' : ''}</span>
                            </div>
                         `;
                    });
                    controlsHtml += '</div>';
                }

                el.innerHTML = `
                <div class="flex justify-between items-center w-full" draggable="false">
                    <div class="flex items-center">
                        <div class="drag-handle" onmousedown="enableDrag(event)" ontouchstart="enableDrag(event)">
                            <svg viewBox="0 0 24 24"><path d="M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
                        </div>
                        <span class="font-bold">${i + 1}. ${o.op.toUpperCase()}</span>
                    </div>
                    <button onclick="removeOp(${i})" class="text-slate-500 hover:text-white" draggable="false">&times;</button>
                </div>
                ${controlsHtml}
            `;
                list.appendChild(el);
            });
        }

        window.updateOpParam = (index, key, value) => {
            const val = parseFloat(value);
            state.ops[index].params[key] = val;

            // Sync UI elements
            const item = document.getElementById('opsList').children[index];
            if (item) {
                const paramIndex = Object.keys(state.ops[index].params).indexOf(key);
                const slider = item.querySelectorAll('input[type="range"]')[paramIndex];
                const input = item.querySelectorAll('input[type="number"]')[paramIndex];

                if (slider) slider.value = val;
                if (input) input.value = val.toFixed(2);
            }
            update();
        };

        window.removeOp = (index) => {
            state.ops.splice(index, 1);
            renderOps();
            update();
        };

        function computeInternalAngle(mesh) {
            if (!mesh || !mesh.faces || mesh.faces.length === 0) return 0;
            const face = mesh.faces[0];
            if (face.length < 3) return 0;

            const v1 = mesh.vertices[face[0]];
            const v2 = mesh.vertices[face[1]];
            const v3 = mesh.vertices[face[2]];

            // Spherical internal angle at v2 is the angle between the planes OV2V1 and OV2V3
            // Vector cross product gives normals to these planes.
            const n1 = new THREE.Vector3().crossVectors(v2, v1).normalize();
            const n2 = new THREE.Vector3().crossVectors(v2, v3).normalize();

            // The angle between normals is the internal angle
            return n1.angleTo(n2);
        }

        window.addOp = (opName) => {
            const def = OP_DEFS[opName];
            const newOp = { op: opName, params: {} };
            if (def && def.params) {
                Object.keys(def.params).forEach(k => {
                    let val = def.params[k].val;
                    if (opName === 'hankin' && k === 'angle') {
                        val = computeInternalAngle(window.currentMesh) / (2 * Math.PI);
                    }
                    newOp.params[k] = val;
                });
            }
            state.ops.push(newOp);
            renderOps();
            update();
        };

        window.resetOps = () => {
            state.ops = [];
            renderOps();
            update();
        };

        window.clearSavedSolids = () => {
            savedSolids.length = 0;
            renderSavedList();
        };

        function update() {
            // 1. Generate Mesh
            let mesh = Solids[state.base]();

            // Deep copy to avoid mutating original registry
            mesh = MeshOps.clone(mesh);

            // Apply Ops
            try {
                state.ops.forEach(o => {
                    const opName = typeof o === 'string' ? o : o.op;
                    if (opName === 'truncate') {
                        mesh = MeshOps.truncate(mesh, o.params.t);
                    } else if (opName === 'hankin') {
                        mesh = MeshOps.hankin(mesh, o.params.angle * 2 * Math.PI);
                    } else if (MeshOps[opName]) {
                        mesh = MeshOps[opName](mesh);
                    }
                });
            } catch (e) {
                console.error(e);
            }

            // 2. Render
            if (mainMesh) scene.remove(mainMesh);
            if (edgeLines) scene.remove(edgeLines);
            if (vertPoints) scene.remove(vertPoints);

            // Faces (Translucent)
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            // Triangulate faces for display
            mesh.faces.forEach(f => {
                // Fan triangulation
                for (let i = 1; i < f.length - 1; i++) {
                    vertices.push(...mesh.vertices[f[0]].toArray());
                    vertices.push(...mesh.vertices[f[i]].toArray());
                    vertices.push(...mesh.vertices[f[i + 1]].toArray());
                }
            });
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({
                color: 0x3b82f6,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
                flatShading: true,
                shininess: 50,
                polygonOffset: true,
                polygonOffsetFactor: 1, // Push back
                polygonOffsetUnits: 1
            });

            mainMesh = new THREE.Mesh(geometry, material);
            if (state.showFaces) scene.add(mainMesh);

            // Vertices
            if (state.showVertices) {
                const dotGeo = new THREE.BufferGeometry().setFromPoints(mesh.vertices);
                const dotMat = new THREE.PointsMaterial({ color: 0xa5b4fc, size: 0.05 });
                vertPoints = new THREE.Points(dotGeo, dotMat);
                scene.add(vertPoints);
            }

            // Edges
            const edgeIndices = new Set();
            mesh.faces.forEach(f => {
                for (let i = 0; i < f.length; i++) {
                    const a = f[i];
                    const b = f[(i + 1) % f.length];
                    const key = a < b ? `${a}_${b}` : `${b}_${a}`;
                    if (!edgeIndices.has(key)) {
                        edgeIndices.add(key);
                    }
                }
            });

            const lineGeoPoints = [];
            edgeIndices.forEach(key => {
                const [ai, bi] = key.split('_').map(Number);
                const va = mesh.vertices[ai];
                const vb = mesh.vertices[bi];

                if (state.showGeodesics) {
                    // Slerp subdivision
                    const steps = 12;
                    for (let j = 0; j < steps; j++) {
                        const t1 = j / steps;
                        const t2 = (j + 1) / steps;
                        const p1 = new THREE.Vector3().copy(va).lerp(vb, t1).normalize().multiplyScalar(1.002);
                        const p2 = new THREE.Vector3().copy(va).lerp(vb, t2).normalize().multiplyScalar(1.002);
                        lineGeoPoints.push(p1, p2);
                    }
                } else {
                    lineGeoPoints.push(va, vb);
                }
            });

            const lineGeo = new THREE.BufferGeometry().setFromPoints(lineGeoPoints);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
            edgeLines = new THREE.LineSegments(lineGeo, lineMat);
            scene.add(edgeLines);

            // Update Live Stats
            mesh.edgeCount = edgeIndices.size;
            document.getElementById('meshStats').innerText = `${mesh.vertices.length}V / ${mesh.edgeCount}E / ${mesh.faces.length}F`;

            // Store current mesh for generation
            window.currentMesh = mesh;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }



        window.onload = init;

    </script>
</body>

</html>